The following text is a Git repository with code. The structure of the text are sections that begin with ----!@#$----, followed by a single line containing the file path and file name, followed by a variable amount of lines containing the file contents. The text representing the Git repository ends when the symbols --END-- are encounted. Any further text beyond --END-- are meant to be interpreted as instructions using the aforementioned Git repository as context.
----!@#$----
README.md
# Swift Splash

 Swift Splash leverages RealityKit and Reality Composer Pro to create a virtual water slide by combining modular slide pieces. When the builder finishes their ride, they can release an adventurous goldfish to try it out. 

For more information about the app and how it works, see
[Hello World](https://developer.apple.com/documentation/visionos/swift-splash) in the developer documentation.

----!@#$----
SwiftSplash/SwiftSplashApp.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The main app class.
*/

import SwiftUI
import SwiftSplashTrackPieces
import RealityKit

@main
@MainActor
struct SwiftSplash: App {
    @Environment(\.openImmersiveSpace) private var openImmersiveSpace
    @Environment(\.dismissWindow) var dismissWindow
    
    /// Pass the app's state object to all SwiftUI views as an environment object.
    @State private var appState = AppState()
    
    @State private var immersionStyle: ImmersionStyle = .mixed
    
    var body: some SwiftUI.Scene {
        WindowGroup(id: "SwiftSplash") {
            ContentView()
                .environment(appState)
                .onChange(of: appState.phase.isImmersed) { _, showMRView in
                    if showMRView {
                        Task {
                            appState.isImmersiveViewShown = true
                            await openImmersiveSpace(id: "Track")
                            dismissWindow(id: "SwiftSplash")
                            appState.music = .build
                        }
                    }
                }
        }
        .windowStyle(.plain)
        .windowResizability(.contentSize)
        
        // Present a mixed immersive space in expanded mode.
        ImmersiveSpace(id: "Track") {
            TrackBuildingView()
                .environment(appState)
        }
        .immersionStyle(selection: $immersionStyle, in: .mixed)
    }
    init() {
        BillboardSystem.registerSystem()
        BillboardComponent.registerComponent()
        
        ConnectableComponent.registerComponent()
        ConnectableStateComponent.registerComponent()
        
        IdleAnimationComponent.registerComponent()
        RideAnimationComponent.registerComponent()
        GlowComponent.registerComponent()
        RideWaterComponent.registerComponent()
    }
}

----!@#$----
SwiftSplash/Data & State/AppState.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The main application state class.
*/

import ARKit
import AVKit
import Combine
import Foundation
import OSLog
import RealityKit
import SwiftSplashTrackPieces
import SwiftUI
import UIKit

/// This contains one case for each connectable piece except the start and goal pieces, which are handled differently.
public enum TilePieceKey: String, CaseIterable, Codable, Sendable {
    case slide1 = "slide_01" // Straight piece
    case slide2 = "slide_02" // Straight slide down
    case slide3 = "slide_03" // Right 90 turn
    case slide4 = "slide_04" // Left 90 turn
    case slide5 = "slide_05" // Spiral
}

/// The types of connection points a slide piece can have. `.inPoint` can only connect to `.outPoint`, and vice versa.
enum ConnectionPointType {
    case inPoint
    case outPoint
    case noPoint
}

/// Application logger for reporting errors, warnings, and useful information.
let logger = Logger(subsystem: "com.apple-samplecode.SwiftSplash", category: "general")

/// An object that maintains app-wide state.
@Observable
@MainActor
public class AppState {
    
     var phase: AppPhase = .startingUp
        
    /// The app's AR session.
     var session: ARKitSession = ARKitSession()
    
    /// The app uses this to retrieve the location and orientation of the device.
     var worldInfo = WorldTrackingProvider()
    
     var meshEntities = [UUID: ModelEntity]()
     var startAttachment: ViewAttachmentEntity?
     var editAttachment: ViewAttachmentEntity?
     var isImmersiveViewShown = false
    
    /// A Boolean that indicates whether the ride is currently running.
     var isRideRunning = false
    
    /// The time the current ride run started or 0 if the ride isn't running.
    var rideStartTime: TimeInterval = 0
    
    var rideDuration: TimeInterval = 0.0
    
    public var lastConnectedPiece: Entity? {
        var lastPiece: Entity? = nil
        var iteratePiece: Entity? = startPiece

        var seen = [Entity]()
        while iteratePiece != nil {
            guard let thePiece = iteratePiece else { break }

            if seen.contains(thePiece) { break }
            seen.append(thePiece)
            lastPiece = iteratePiece
            if let next = iteratePiece?.connectableStateComponent?.nextPiece {
                if next != placePieceMarker {
                    iteratePiece = iteratePiece?.connectableStateComponent?.nextPiece
                } else {
                    iteratePiece = nil
                }
            } else {
                iteratePiece = nil
            }
        }
        return lastPiece
    }
    
    var presentedRide = [RideDestination]()
    
    /// Stores the track piece that's currently selected and in edit mode. Only one track can be in edit mode at a time, but any number
    /// of additional pieces can be selected and any edit actions apply to them all. There doesn't have to be a  piece in edit mode, but
    /// if no piece is in edit mode, there should be no additional selected track pieces.
    var trackPieceBeingEdited: Entity?

    var isVolumeMuted = false {
        didSet {
            SoundEffect.isMuted = isVolumeMuted
            if isVolumeMuted {
                [buildMusic, menuMusic, rideMusic].forEach { $0.volume = 0 }
                SoundEffect.stopLoops()
            } else {
                [buildMusic, menuMusic, rideMusic].filter { $0.isPlaying }.forEach {
                    $0.volume = 1.0
                }
            }
        }
    }
    
    /// Indicates whether the ride can be started,
    public var canStartRide: Bool {
        guard let startPiece = startPiece else { fatalError("Start piece is missing.") }
        guard let goalPiece = goalPiece else { fatalError("Goal piece is missing") }
        
        // Goal piece is not in the scene, can't start ride
        if goalPiece.parent == nil { return false }
        
        var iteratePiece: Entity? = startPiece
        var lastPiece: Entity? = nil
        while iteratePiece != nil {
            
            if iteratePiece?.connectableStateComponent?.nextPiece == nil {
                lastPiece = iteratePiece
            }
            iteratePiece = iteratePiece?.connectableStateComponent?.nextPiece
        }
        if lastPiece != goalPiece { return false }
        
        return true
    }
    
    var music: MusicMode = .silent {
        didSet {
            if oldValue == music {
                return
            }
            let playerMap: [MusicMode: AVAudioPlayer] = [
                .build: buildMusic,
                .menu: menuMusic,
                .ride: rideMusic
            ]
            
            let oldPlayer = playerMap[oldValue]
            let newPlayer = playerMap[music]
            
            let crossfade = music == .silent ? 0.0 : 3.0
            
            oldPlayer?.setVolume(0, fadeDuration: crossfade)
            Timer.scheduledTimer(withTimeInterval: crossfade, repeats: false) { timer in
                oldPlayer?.stop()
            }

            if !isVolumeMuted {
                newPlayer?.volume = 0
                newPlayer?.numberOfLoops = -1
                newPlayer?.currentTime = 0
                newPlayer?.play()
                newPlayer?.setVolume(music.volume, fadeDuration: crossfade)
            }
        }
    }
    
    let connectableQuery = EntityQuery(where: .has(ConnectableComponent.self))
    
    /// Stores any additional selected pieces. Any action taken to the piece being edited applies to these as well.
    var additionalSelectedTrackPieces = [Entity]()
    
    /// An array of all the pieces available to place in a scene excluding the start and end pieces.
     public var pieces = [
        Piece(name: "Straight", key: .slide1, sceneName: "Slide01.usda"),
        Piece(name: "Slide", key: .slide2, sceneName: "Slide02.usda"),
        Piece(name: "Right Turn", key: .slide3, sceneName: "Slide03.usda"),
        Piece(name: "Left Turn", key: .slide4, sceneName: "Slide04.usda"),
        Piece(name: "Spiral", key: .slide5, sceneName: "Slide05.usda")
    ]
    init() {
        root.name = "Root"
        Task.detached(priority: .high) {
            
            do {
                try await self.session.run([self.worldInfo])
            } catch {
                logger.error("Error running World Tracking Provider: \(error.localizedDescription)")
            }
            // Load the pieces from the Reality Composer Pro file into memory.
            await self.loadPieces()
            Task { @MainActor in
                guard let goalPiece = self.goalPiece else { return }
                goalPiece.forEachDescendant(withComponent: ParticleEmitterComponent.self) { entity, component in
                    var component = component
                    component.isEmitting = false
                    entity.components[ParticleEmitterComponent.self] = component
                    entity.components.set(component)
                }
            }
        }
        
        // Load sounds.
        Task {
            for effect in SoundEffect.allCases {
                let resource = try await AudioFileResource(named: "\(effect.rawValue).wav")
                SoundEffect.soundForEffect[effect] = resource
            }
        }
    }
    
    // Background music.
    public var buildMusic = try! AVAudioPlayer(contentsOf: Bundle.main.url(forResource: "swiftSplash_BuildMode", withExtension: "wav")!)
    public var menuMusic = try! AVAudioPlayer(contentsOf: Bundle.main.url(forResource: "swiftSplash_Menu", withExtension: "wav")!)
    public var rideMusic = try! AVAudioPlayer(contentsOf: Bundle.main.url(forResource: "swiftSplash_RideMode", withExtension: "m4a")!)
    
    // MARK: - Piece Entities -
    
    /// A dictionary of pieces loaded from the Reality Composer Pro scene. This app
    /// doesn't add the Reality Composer Pro scene to the `RealityView` directly.
    /// Instead, it pulls out each of the root entities and stores them to use
    /// as a template. When adding a new piece, the app clones the template
    /// piece and adds it to the scene.
    var pieceTemplates = [TilePieceKey: Entity]()
    
    /// The root entity for the `RealityView` scene. Storing this in application
    /// state means any code in the app can get access to it.
    public var root = Entity()
    
    /// The piece from which the player starts building the ride.
    public var startPiece: Entity?
    
    /// The last piece of a track. This must be placed to start the ride.
    public var goalPiece: Entity?
    
    /// A special entity that shows where the next track piece will go.
    public var placePieceMarker: Entity?
    
    /// The current material selection. This is used when adding a track piece. It
    /// also updates the button image file names to reflect the current material selection.
    public var selectedMaterialIndex: Int = MaterialType.metal.rawValue
    
    /// These hold the button image filenames. They're updated whenever the material index changes so the UI
    /// always shows the track piece buttons with the correct material applied.
    public var simpleRampImageName: String {
        "slide_01_\(selectedMaterialType.name)"
    }
    public var slideImageName: String {
        "slide_02_\(selectedMaterialType.name)"
    }
    public var rightTurnImageName: String {
        "slide_03_\(selectedMaterialType.name)"
    }
    public var leftTurnImageName: String {
        "slide_05_\(selectedMaterialType.name)"
    }
    public var spiralImageName: String {
        "slide_04_\(selectedMaterialType.name)"
    }
    public var goalImageNamne: String {
        "goal_\(selectedMaterialType.name)"
    }
    
    /// A convenience accessor to get the `MaterialType` corresponding to the current selected material index.
    public var selectedMaterialType: MaterialType {
        get {
            return MaterialType(rawValue: selectedMaterialIndex) ?? .metal
        } set {
            selectedMaterialIndex = newValue.rawValue
        }
    }
    
    /// A sort order group used for all of the track pieces other than start and end.
    let trackPieceSortOrderGroup = ModelSortGroup()
}

@MainActor
struct RideDestination: Identifiable, Hashable {
    let id = "ride"
}

----!@#$----
SwiftSplash/Data & State/AppState+Phases.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to the app phase.
*/

import ARKit
import Combine
import Foundation
import RealityKit
import SwiftSplashTrackPieces
import UIKit
/// These methods expose valid state changes in the app's phase.
extension AppState {
    
    /// Call this to change app phase when you begin loading assets.
    public func finishedStartingUp() {
        phase.transition(to: .loadingAssets)
        isRideRunning = false
        rideStartTime = 0
    }
    
    /// Call this once the Reality Composer Pro project has been loaded and the template pieces created.
    public func finishedLoadingAssets() {
        phase.transition(to: .waitingToStart)
        isRideRunning = false
        rideStartTime = 0
    }
    
    /// Call this after the player has chosen the game style.
    public func startBuilding() {
        phase.transition(to: .placingStartPiece)
        isRideRunning = false
        rideStartTime = 0
        guard let startPiece = startPiece else {
            fatalError("Start piece not loaded.")
        }
        root.addChild(startPiece)
        startPiece.connectableStateComponent?.isSelected = false
        setStartPieceInitialPosition()
        trackPieceBeingEdited = nil
        clearSelection()
        updateSelection()
        startPiece.updateTrackPieceAppearance()
    }
    
    /// Call this to change the app phase after starting to drag the start piece.
    public func startedDraggingStartPiece() {
        phase.transition(to: .draggingStartPiece)

        isRideRunning = false
        rideStartTime = 0
        startAttachment?.removeFromParent()
    }
    
    /// Call this to change the app phase after the initial drag of the start piece has finished.
    public func finishedDraggingStartPiece() {
        phase.transition(to: .buildingTrack)
    }
    
    /// Starts the ride running from the start piece to the goal.
    public func startRide() {
        clearSelection()
        shouldCancelRide = false
        isRideRunning = true
        phase.transition(to: .rideRunning)
        startPiece?.setRideLights(to: true)
        goalPiece?.setRideLights(to: true)
        pauseStartTime = 0
        removeHoverEffectFromConnectibles()
        
        rideStartTime = Date.timeIntervalSinceReferenceDate
        if let startPiece = startPiece {
            startPiece.setUpAnimationVisibility()
            var nextPiece: Entity? = startPiece.connectableStateComponent?.nextPiece
            while nextPiece != nil {
                nextPiece?.setUpAnimationVisibility()
                nextPiece?.playIdleAnimations()
                
                if let currentPiece = nextPiece {
                    currentPiece.forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
                        if component.alwaysAnimates {
                            for animation in entity.availableAnimations {
                                let animation = animation.repeat(count: Int.max)
                                let controller = entity.playAnimation(animation, transitionDuration: 0.0, startsPaused: false)
                                rideAnimationcontrollers.append(controller)
                                controller.resume()
                                controller.speed = Float(animationSpeedMultiplier)
                            }
                        }
                    }
                }
                nextPiece = nextPiece?.connectableStateComponent?.nextPiece
            }
        }

        SoundEffect.trapDoor.play(on: startPiece ?? root)
        music = .ride
        
        SoundEffect.enqueueEffectsForRide(self)
        
        if let startPiece = startPiece {
            startRideLights()
            startWaterFilling()
            calculateRideDuration()
            hideEditAttachment()
            startPiece.playRideAnimations()
        }
        
        updateSelection()
    }
    
    /// Call this to return to the splash screen and delete the current track.
    func goBackToWaiting() {
        if phase.transition(to: .waitingToStart) {
            resetBoard()
            isRideRunning = false
            rideStartTime = 0
            if trackPieceBeingEdited != nil {
                showEditAttachment()
            }
        }
    }
    
    /// Call this to go back to building or editing the track after calling `finishBuildingTrack()` or `startRide()`.
    func returnToBuildingTrack() {
        phase.transition(to: .buildingTrack)
    }
}

----!@#$----
SwiftSplash/Data & State/Piece.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An object that holds information about one slide piece.
*/

import Foundation
import Combine
import SwiftSplashTrackPieces
import UIKit
import RealityKit
/// Represents a single connectable track piece, including elements used in UI, such as name and image.
public struct Piece: Identifiable {
    
    /// The name of the piece to display in UI.
    public var name: String
    
    /// The corresponding key to store this piece in dictionaries.
    public var key: TilePieceKey
    
    /// The scene in the Reality Composer Pro project that contains the piece.
    public var sceneName: String
    
    init(name: String, key: TilePieceKey,
         sceneName: String) {
        self.name = name
        self.key = key
        self.id = UUID()
        self.sceneName = sceneName
    }
    
    /// Calcualate ID based on name, which must be unique.
    public var id: UUID
}

/// Implements `Codable` for `Piece`. Because the sample has derived keys, this object can't use auto encoding.
extension Piece: Codable {
    
    enum CodingKeys: String, CodingKey {
        case name
        case key
        case imageFilename
        case sceneName
    }
    
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(key.rawValue, forKey: .key)
        try container.encode(sceneName, forKey: .sceneName)
    }
    
    public enum PieceError: Error {
        case unableToDecodeKeyError
    }
    
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        let name = try container.decode(type(of: name), forKey: .name)
        let keyString = try container.decode(String.self, forKey: .key)
        let sceneName = try container.decode(String.self, forKey: .sceneName)
        guard let key = TilePieceKey(rawValue: keyString) else { throw PieceError.unableToDecodeKeyError }
        
        self.init(name: name, key: key, sceneName: sceneName)
    }
}


----!@#$----
SwiftSplash/Data & State/AppState+PieceSelection.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to user selection of slide pieces.
*/
import ARKit
import Combine
import Foundation
import RealityKit
import SwiftSplashTrackPieces
import UIKit

extension AppState {
    /// Call this to deselect all currently selected pieces.
    public func deleteSelectedPieces() {
        guard let entity = trackPieceBeingEdited else {
            logger.error("Delete requested, but no piece is currently being edited.")
            return
        }
        
        Task {
            SoundEffect.deletePiece.play(on: startPiece ?? root)
            if entity == startPiece {
                entity.connectableStateComponent?.isSelected = false
            } else if entity == goalPiece {
                removeGoalPiece()
            } else {
                entity.connectableStateComponent?.isSelected = false
                entity.connectableStateComponent?.previousPiece?.connectableStateComponent?.nextPiece = nil
                entity.connectableStateComponent?.nextPiece?.connectableStateComponent?.previousPiece = nil
                entity.removeFromParent()
            }
            
            for selected in additionalSelectedTrackPieces where selected.name != startPieceName {
                selected.connectableStateComponent?.isSelected = false
                selected.connectableStateComponent?.previousPiece?.connectableStateComponent?.nextPiece = nil
                selected.connectableStateComponent?.nextPiece?.connectableStateComponent?.previousPiece = nil
                selected.removeFromParent()
            }
            additionalSelectedTrackPieces.removeAll()
            try? await Task.sleep(for: .seconds(0.1))
            trackPieceBeingEdited = nil
            startPiece?.connectableStateComponent?.isSelected = false
            hideEditAttachment()
            updateConnections()
            updatePower()
            updateMarkerPosition()
            updateSelection()
        }
    }
    
    /// Call this to add or remove a specified entity from the list of selected entities.
    public func toggleTrackPieceInSelection(entity: Entity) {
        if additionalSelectedTrackPieces.contains(entity) {
            entity.connectableStateComponent?.isSelected = false
            if let index = additionalSelectedTrackPieces.firstIndex(of: entity) {
                additionalSelectedTrackPieces.remove(at: index)
            }
            showEditAttachment()
        } else {
            additionalSelectedTrackPieces.append(entity)
            entity.connectableStateComponent?.isSelected = true
            showEditAttachment()
        }
    }
    
    /// Call this to de-select all of the pieces. Provides an option to keep the main selection (the entity with the UI above it).
    public func clearSelection(keepPrimary: Bool = false) {
        guard trackPieceBeingEdited != nil else { return }
        additionalSelectedTrackPieces.forEach { entity in
            entity.connectableStateComponent?.isSelected = false
        }
        additionalSelectedTrackPieces.removeAll()
        
        unmarkAllPieces()
        if !keepPrimary {
            trackPieceBeingEdited = nil
        }
        updateConnections()
        updatePower()
        updateSelection()
        editAttachment?.removeFromParent()
    }
    
    ///  De-selects all of the pieces.
    public func unmarkAllPieces() {
        
        let children = [Entity](root.children)
        
        for entity in children {
            guard entity.connectableStateComponent != nil else {
                continue
            }
            entity.connectableStateComponent?.isSelected = false
        }
    }
    
    /// Select all of the pieces.
    public func selectAll() {
        let children = [Entity](root.children)
        for entity in children {
            guard let entity = entity.connectableAncestor else {
                continue
            }
            if !additionalSelectedTrackPieces.contains(entity) &&
                entity != trackPieceBeingEdited &&
                entity.name != SwiftSplashTrackPieces.startPieceName {
                additionalSelectedTrackPieces.append(entity)
                entity.connectableStateComponent?.isSelected = true
            }
        }
        updateConnections()
        updatePower()
        updateSelection()
    }
    
    /// This function updates the entity visuals to reflect the selection status of the track pieces.
    public func markSelectedPieces() {
        unmarkAllPieces()
        
        root.forEachDescendant(withComponent: ConnectableComponent.self) { entity, component in
            if additionalSelectedTrackPieces.contains(entity) || entity == trackPieceBeingEdited {
                entity.connectableStateComponent?.isSelected = true
            }
        }
    }
    
    /// Selects all slide pieces that connect back to the start piece.
    public func selectConnectedPieces() {
        guard let entity = trackPieceBeingEdited else { return }
        entity.connectableStateComponent?.isSelected = true
        
        // Select all pieces in front of the selected piece.
        var piece: Entity? = entity
        while piece?.connectableStateComponent?.nextPiece != nil {
            piece = piece?.connectableStateComponent?.nextPiece
            piece?.connectableStateComponent?.isSelected = true
            if let thePiece = piece {
                additionalSelectedTrackPieces.append(thePiece)
            }
        }
        
        // Select all pieces behind the selected piece.
        piece = entity
        while piece?.connectableStateComponent?.previousPiece != nil {
            piece = piece?.connectableStateComponent?.previousPiece
            piece?.connectableStateComponent?.isSelected = true
            if let thePiece = piece {
                additionalSelectedTrackPieces.append(thePiece)
            }
        }
        updateSelection()
    }
    
    /// Returns the center point of the union of the bounding boxes for all selected track pieces. This is used as a rotation pivot point
    /// when rotating multiple pieces together.
    public var selectedTrackRotationPoint: SIMD3<Float> {
        guard var selectedExtents = trackPieceBeingEdited?.visualBounds(relativeTo: nil) else { return .zero }
        
        for entity in additionalSelectedTrackPieces {
            selectedExtents = selectedExtents.union(entity.visualBounds(relativeTo: nil))
        }
        return selectedExtents.center
    }
    
    public func entityIsInAdditionalSelectedTrackPieces(_ entity: Entity?) -> Bool {
        guard let entity = entity else { return false }
        return additionalSelectedTrackPieces.contains(entity)
    }
    
    public func setMaterialForAllSelected(_ material: MaterialType) {
        if let piece = trackPieceBeingEdited {
            piece.connectableStateComponent?.material = material
            piece.updateTrackPieceAppearance()
            
            for additionalPiece in additionalSelectedTrackPieces {
                additionalPiece.connectableStateComponent?.material = material
                additionalPiece.updateTrackPieceAppearance()
            }
        }
    }
    
    /// Shows the edit attachment over the selected piece.
    public func showEditAttachment() {
        if let editMenu = editAttachment {
            if editMenu.parent != nil {
                editMenu.removeFromParent()
            }
            // Parent to root so it doesn't highlight from the entity's HoverEffectComponent.
            root.addChild(editMenu)

            // Set its position based on the selected piece.
            if let position = trackPieceBeingEdited?.uiAnchor?.scenePosition {
                editMenu.scenePosition = position
            }
        }
    }
    
    /// Hides the edit attachment.
    public func hideEditAttachment() {
        if let editMenu = editAttachment {
            editMenu.removeFromParent()
        }
    }
}

----!@#$----
SwiftSplash/Data & State/SoundEffects.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An object that plays the app's sound effects and music.
*/
import AVKit
import RealityKit

/// The kinds of background music that play during different parts of the game.
public enum MusicMode {
    case menu
    case build
    case ride
    
    case silent
    
    var volume: Float {
        switch self {
        case .menu: 0.4
        case .build: 0.4
        case .ride: 0.4
        case .silent: 0.0
        }
    }
}

/// The sound effects available for playing when you take certain actions.
public enum SoundEffect: String, CaseIterable {
    case placePiece = "placePiece"
    case deletePiece = "deletePiece"
    case selectPiece = "pickUp"
    
    case water = "waterFlowing"
    case trapDoor = "startRide"
    case fishDrop = "fishSound_longLoudHappy"
    case fishSlide = "fishSound_mediumHappy"
    case fishGasp = "fishSound_quietHappy"
    case fishSucceed = "endRide"
    
    /// Plays a sound effect from an entity.
    func play(on entity: Entity, offset: Duration? = nil) {
        guard let effect = Self.soundForEffect[self] else {
            fatalError("No sound asset for effect: \(self)")
        }
        
        let audioController = entity.prepareAudio(effect)
        audioController.gain = gain
        
        if !Self.isMuted {
            if let offset = offset {
                audioController.seek(to: offset)
            }
            audioController.play()
            
            let cancellation = {
                audioController.stop()
            }
            
            Self.loopCancellations.append((self, cancellation))
        }
    }
    
    @discardableResult
    func loopingPlay(on entity: Entity) -> () -> Void {
        guard let effect = Self.soundForEffect[self] else {
            fatalError("No sound asset for effect: \(self)")
        }
        
        var shouldLoop = true
        let audioController = entity.prepareAudio(effect)
        audioController.gain = gain
        audioController.completionHandler = {
            if shouldLoop {
                audioController.play()
            }
        }
        
        if !Self.isMuted {
            audioController.play()
        }
        
        let cancellation = {
            shouldLoop = false
            audioController.stop()
        }
        
        Self.loopCancellations.append((self, cancellation))
        
        return cancellation
    }
    
    /// Plays a random sound effect at random time intervals.
    static func randomAmbientPlay(on entity: Entity) {
        var shouldLoop = true
        var audioController: AudioPlaybackController? = nil
        
        func recursiveCompletion() {
            if shouldLoop {
                randomLater {
                    if !shouldLoop {
                        return
                    }
                    
                    let effect: Self = [.fishDrop, .fishSlide, .fishGasp].randomElement()!
                    let newController = entity.prepareAudio(Self.soundForEffect[effect]!)
                    newController.gain = effect.gain
                    if !Self.isMuted {
                        newController.play()
                    }
                    newController.completionHandler = recursiveCompletion
                    audioController = newController
                }
            }
        }
        
        recursiveCompletion()
        
        let cancellation = {
            shouldLoop = false
            audioController?.stop()
        }
        
        Self.loopCancellations.append((.fishDrop, cancellation))
    }
    
    var gain: Double {
        switch self {
        case .placePiece: 0
        case .deletePiece: 0
        case .selectPiece: 0
        case .water: -10
        case .trapDoor: 0
        case .fishDrop: 0
        case .fishSlide: 0
        case .fishGasp: 0
        case .fishSucceed: 0
        }
    }
    
    /// Calls a closure at a random time in the future.
    private static func randomLater(_ perform: @escaping () -> Void) {
        Timer.scheduledTimer(withTimeInterval: Double.random(in: 7...11), repeats: false) { timer in
            perform()
        }
    }
    
    @MainActor
    public static func enqueueEffectsForRide(_ appState: AppState, resume: Bool = false) {
        let elapsed = (Date.timeIntervalSinceReferenceDate - appState.rideStartTime)
        
        if resume, elapsed < ambientSoundsDelay {
            Self.trapDoor.play(on: appState.startPiece ?? appState.root, offset: .seconds(elapsed))
        }
        
        let waterStartTime = waterStartDelay - elapsed
        var waterTimer: Timer? = nil
        if waterStartTime >= 0 {
            waterTimer = Timer.scheduledTimer(withTimeInterval: waterStartTime, repeats: false) { _ in
                Task { @MainActor in
                    if appState.phase == .rideRunning, !appState.isVolumeMuted {
                        SoundEffect.water.loopingPlay(on: appState.startPiece ?? appState.root)
                    }
                }
            }
        }
        
        let ambientStartTime = ambientSoundsDelay - elapsed
        var ambientTimer: Timer? = nil
        
        if ambientStartTime >= 0 {
            ambientTimer = Timer.scheduledTimer(withTimeInterval: ambientStartTime, repeats: false) { _ in
                Task { @MainActor in
                    if appState.phase == .rideRunning && !appState.isVolumeMuted {
                        SoundEffect.randomAmbientPlay(on: appState.startPiece ?? appState.root)
                    }
                }
            }
        }
        
        // Potentially cancel these early if the ride is paused or reset.
        loopCancellations.append((.water, {
            waterTimer?.invalidate()
        }))
        
        loopCancellations.append((nil, {
            ambientTimer?.invalidate()
        }))
    }
    
    /// A mapping of sound effect types to their associated audio resource.
    ///
    /// This map is populated during the asset loading phase when the app starts.
    public static var soundForEffect: [SoundEffect: AudioFileResource] = [:]
    public static var loopCancellations: [(effect: SoundEffect?, closure: () -> Void)] = []
    public static var isMuted = false
    
    public static func stopLoops() {
        loopCancellations.forEach { $0.closure() }
        loopCancellations = []
    }
    
    public static func stopLoops(for effect: Self?) {
        loopCancellations.forEach {
            if let effect = effect, $0.effect == effect {
                $0.closure()
            }
            
            if effect == nil, $0.effect == nil {
                $0.closure()
            }
        }
    }
}

----!@#$----
SwiftSplash/Data & State/AppPhase.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A simple state machine used to keep track of the app's current state.
*/
import Foundation

/// Enum that tracks the current phase of the game by implementing a simple state machine.
public enum AppPhase: String, Codable, Sendable, Equatable {
    case startingUp         // Launching app
    case loadingAssets      // Loading assets from the Reality Composer Pro project
    case waitingToStart     // At the main menu
    case placingStartPiece  // Placing the first piece of track
    case draggingStartPiece // Has started, but not finished, dragging the start piece
    case buildingTrack      // Working on the ride
    case rideRunning        // Ride animations running
    
    /// Controls whether the mixed reality view containing the ride is visible.
    var isImmersed: Bool {
        switch self {
            case .startingUp, .loadingAssets, .waitingToStart:
                return false
            case .placingStartPiece, .draggingStartPiece, .buildingTrack, .rideRunning:
                return true
        }
    }
    
    /// Returns `True` if it's possible to transition to the specified phase from the currrent one.
    func canProgress(to phase: AppPhase) -> Bool {
        switch self {
            case .startingUp:
                return phase == .loadingAssets
            case .loadingAssets:
                return phase == .waitingToStart
            case .waitingToStart:
                return phase == .placingStartPiece
            case .placingStartPiece:
                return phase == .draggingStartPiece
            case .draggingStartPiece:
                return [.waitingToStart, .buildingTrack].contains(phase)
            case .buildingTrack:
                return [.rideRunning, .waitingToStart].contains(phase)
            case .rideRunning:
                return [.waitingToStart, .buildingTrack].contains(phase)
        }
    }
    
    /// Requests a phase transition.
    @discardableResult
    mutating public func transition(to newPhase: AppPhase) -> Bool {
        logger.info("Phase change to \(newPhase.rawValue)")
        guard self != newPhase else {
            logger.debug("Attempting to change phase to \(newPhase.rawValue) but already in that state. Treating as a no-op.")
            return false
        }
        guard canProgress(to: newPhase) else {
            logger.error("Requested transition to \(newPhase.rawValue), but that's not a valid transition.")
            return false
        }
        self = newPhase
        return true
    }
  
}

----!@#$----
SwiftSplash/Data & State/AppState+RideRunning.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to running the water ride.
*/

import ARKit
import Combine
import Foundation
import RealityKit
import SwiftSplashTrackPieces
import UIKit

/// These methods expose valid state changes in the app's phase.
extension AppState {
    
    /// Calculates the duration of the built ride by summing up the individual slide piece durations.
    public func calculateRideDuration() {
        guard let startPiece = startPiece else { fatalError("No start piece found.") }
        var nextPiece: Entity? = startPiece
        var duration: TimeInterval = 0
        while nextPiece != nil {
            // Some pieces have more than one ride animation. Use the longest one to calculate duration.
            var longestAnimation: TimeInterval = 0
            nextPiece?.forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
                longestAnimation = max(component.duration, longestAnimation)
            }
            duration += longestAnimation
            nextPiece = nextPiece?.connectableStateComponent?.nextPiece
        }
        // Remove the part of the animation after the goal post.
        rideDuration = duration / animationSpeedMultiplier + 1.0
    }
    
    /// Call this when returning to build mode to reset the animations and hide the moving fish and water.
    public func resetRideAnimations() {
        guard let startPiece = startPiece else { fatalError("No start piece found.") }
        
        for controller in rideAnimationcontrollers {
            controller.pause()
            controller.time = 0
        }
        rideAnimationcontrollers.removeAll()
        
        var currentPiece: Entity? = goalPiece
        Task {
            try await Task.sleep(for: .seconds(10))
            while currentPiece != nil {
                currentPiece?.setRideLights(to: false)
                currentPiece = currentPiece?.connectableStateComponent?.previousPiece
            }
        }
        
        var nextPiece: Entity? = startPiece
        while nextPiece != nil {
            if let nextpiece = nextPiece {
                nextpiece.setWaterLevel(level: 0)
                nextpiece.setAllParticleEmittersTo(to: false)
                nextpiece.forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
                    entity.isEnabled = component.isPersistent
                    
                    for animation in entity.availableAnimations {
                        let animation = animation.repeat(count: Int.max)
                        let controller = entity.playAnimation(animation, transitionDuration: 0.0, startsPaused: true)
                        controller.time = component.timecodeWhenNotPlaying
                    }
                }
            }
            nextPiece?.setUpAnimationVisibility()
            nextPiece = nextPiece?.connectableStateComponent?.nextPiece
        }
        
        startPiece.setRideLights(to: false)
        goalPiece?.setRideLights(to: false)
        
    }
}

----!@#$----
SwiftSplash/Data & State/AppState+TrackUpdates.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions that update app visuals based on current state.
*/

import ARKit
import Combine
import Foundation
import SwiftSplashTrackPieces
import RealityKit
import UIKit
extension AppState {
    
    func updateVisuals() {
        markSelectedPieces()
        updateMarkerPosition()
        updateSelection()
        updatePower()
        if let lastPiece = lastConnectedPiece {
            placeMarker(at: lastPiece)
        }
    }
    
    func updateConnections() {
        let entities = root.scene?.performQuery(connectableQuery)
        entities?.forEach() { piece in
            findClosestPieces(for: piece)
        }
        
        var entity: Entity? = goalPiece
        var seenEntities = [Entity]()
        while entity != nil {
            // If the player creates a track that loops back onto itself, this
            // prevents an infinite loop from happening when iterating through
            // the pieces.
            if let entity = entity {
                if seenEntities.contains(entity) {
                    logger.error("Player created a loop. Refusing to connect.")
                    break
                }
                seenEntities.append(entity)
            }
            
            entity = entity?.connectableStateComponent?.previousPiece
        }
    }
    
    func updatePower() {
        
        // Set the power on all connectable entities to off.
        let entities = root.scene?.performQuery(connectableQuery)
        entities?.forEach { entity in
            entity.setPower(isPowered: false)
        }
        
        // Set connected entities to on.
        var entity = startPiece
        var seenEntities = [Entity]()
        while entity != nil {
            // If the player creates a track that loops back onto itself, this
            // prevents an infinite loop from happening when iterating through
            // the pieces.
            if let entity = entity {
                if seenEntities.contains(entity) {
                    logger.error("Player created a loop. Refusing to connect.")
                    break
                }
                seenEntities.append(entity)
            }
            entity?.setPower(isPowered: true)
            entity = entity?.connectableStateComponent?.nextPiece
        }
    }
    
    func updateSelection() {
        let entities = root.scene?.performQuery(connectableQuery)
        
        var seenEntities = [Entity]()
        entities?.forEach { entity in
            // If the player creates a track that loops back onto itself, this
            // prevents an infinite loop from happening when iterating through
            // the pieces.
            if seenEntities.contains(entity) {
                logger.error("Player created a loop. Refusing to connect.")
                return
                
            }
            seenEntities.append(entity)
            guard entity.name != placePieceMarkerName else {
                return
            }
            guard let state = entity.connectableStateComponent else {
                return
            }
            
            entity.forEachDescendant(withComponent: GlowComponent.self) { entity, component in
                entity.isEnabled = state.isSelected
            }
            entity.updateTrackPieceAppearance()
        }
        updateMarkerPosition()
    }
    
    /// This function looks at both entities' available connection points and looks for other slide pieces
    /// they're close enough to snap to.
    func findNearestConnectionPoint (entity: Entity,
                                     connectionType: ConnectionPointType) -> (closestEntity: Entity?, distance: Float) {
        
        guard connectionType != .noPoint,
              let ourConnection = (connectionType == .inPoint) ? entity.inConnection : entity.outConnection,
              let ourVectorEntity = (connectionType == .inPoint) ? entity.inConnectionVector : entity.outConnectionVector  else {
            return (nil, Float.greatestFiniteMagnitude)
        }
        
        guard let otherEntities = entity.scene?.performQuery(connectableQuery) else { return (nil, Float.greatestFiniteMagnitude) }
        
        var closestDistance = Float.greatestFiniteMagnitude
        var closestEntity: Entity? = nil
        otherEntities.forEach() { oneEntity in
            guard oneEntity != entity && oneEntity != placePieceMarker ,
                  let theirConnection = (connectionType == .inPoint) ? oneEntity.outConnection : oneEntity.inConnection,
                  let theirVectorEntity = (connectionType == .inPoint) ? oneEntity.outConnectionVector : oneEntity.inConnectionVector else {
                return
            }
            
            let ourConnectionVector = simd_normalize(ourVectorEntity.scenePosition)
            let theirConnectionVector = simd_normalize(theirVectorEntity.scenePosition)
            
            // Make sure the orientation of the pieces is right for connection or snapping.
            let dot = simd_dot(ourConnectionVector, theirConnectionVector)
            if dot >= 0.9 && dot <= 1.1 {
                let delta = theirConnection.scenePosition - ourConnection.scenePosition
                let distance = delta.magnitude
                if distance < closestDistance {
                    closestEntity = oneEntity
                    closestDistance = distance
                }
            }
        }
        
        return (closestEntity, closestDistance)
    }
    
    /// This function turns the side lights on or off for all pieces connected to the start piece.
    func setAttachedTrackLights(to isOn: Bool) {
        guard let startPiece = startPiece else { return }
        var checkPiece: Entity? = startPiece
        while checkPiece?.connectableStateComponent?.nextPiece != nil {
            checkPiece?.setRideLights(to: isOn)
            checkPiece = checkPiece?.connectableStateComponent?.nextPiece
        }
    }
    
    /// Turns on the animated ride lights.
    func startRideLights() {
        setAttachedTrackLights(to: true)
    }
    
    /// Turns off the animated ride lights.
    func stopRideLights() {
        setAttachedTrackLights(to: false)
    }
    
    /// Starts water flowing through the ride.
    func startWaterFilling() {
        Task {
            if shouldCancelRide { return }
            try? await Task.sleep(for: .seconds(waterStartDelay))
            
            guard let startPiece = self.startPiece else { fatalError("Start piece is missing.") }
            
            var currentPiece: Entity? = startPiece
            var pieceStartTime: TimeInterval = Date.timeIntervalSinceReferenceDate
            while currentPiece != nil {
                if shouldCancelRide { return }
                try? await Task.sleep(for: .milliseconds(15))
                
                var maxFillLevel: Float?
                var duration: Float?
                currentPiece?.forEachDescendant(withComponent: RideWaterComponent.self) { entity, component in
                    maxFillLevel = component.fillLevel
                    duration = component.duration
                }
                
                guard let maxFillLevel = maxFillLevel,
                      let duration = duration else {
                    fatalError("No ride water component found.")
                }
                
                let adjustedPieceStartTime = (shouldPauseRide) ? pieceStartTime + Date.timeIntervalSinceReferenceDate - pauseStartTime
                : pieceStartTime
                let fillLevel = Float(Date.timeIntervalSinceReferenceDate - adjustedPieceStartTime) * duration
                
                currentPiece?.setWaterLevel(level: fillLevel)
                if fillLevel >= maxFillLevel {
                    pieceStartTime = Date.timeIntervalSinceReferenceDate
                    
                    currentPiece = currentPiece?.connectableStateComponent?.nextPiece
                }
            }
            if shouldCancelRide { return }
            goalPiece?.setAllParticleEmittersTo(to: true, except: [fireworksParticlesName, fishSplashParticleName])
        }
    }
}

extension Entity {
    /// Turns ride lights on or off or change the speed of the color changes by setting promoted property values on Shader Graph materials.
    func setRideLights(to isOn: Bool, speed: Float = 1.0) {
        forEachDescendant(withComponent: ModelComponent.self) { modelEntity, component in
            var modelComponent = component
            modelComponent.materials = modelComponent.materials.map {
                guard var material = $0 as? ShaderGraphMaterial else { return $0 }
                do {
                    if material.parameterNames.contains(rideRunningParameterName) {
                        
                        try material.setParameter(name: rideRunningParameterName,
                                                  value: MaterialParameters.Value.bool(isOn))
                    }
                    if material.parameterNames.contains(speedMultiplierParameterName) {
                        try material.setParameter(name: speedMultiplierParameterName,
                                                  value: MaterialParameters.Value.float(speed))
                    }
                } catch {
                    logger.error("Error setting ride_running material parameter: \(error.localizedDescription)")
                }
                return material
            }
            modelEntity.modelComponent = modelComponent
        }
    }
}

----!@#$----
SwiftSplash/Data & State/AppState+PieceManagement.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to managing slide pieces.
*/
import ARKit
import Combine
import Foundation
import RealityKit
import SwiftUI
import SwiftSplashTrackPieces
import UIKit

extension AppState {
    
    // MARK: - Marker -
    // Places the next piece placeholder so it's connected to the specified entity.
    public func placeMarker(at entity: Entity) {
        guard let marker = placePieceMarker else { return }
        marker.isEnabled = true
        if marker.parent == nil {
            root.addChild(marker)
        }
        connect(piece: marker, to: entity)
    }
    
    public func updateMarkerPosition() {
        guard let marker = placePieceMarker,
              let lastConnectedPiece = lastConnectedPiece else { return }
        
        // Don't show the connection marker if there's no place for a piece to connect.
        if lastConnectedPiece == goalPiece {
            marker.removeFromParent()
            return
        } else if marker.parent == nil {
            root.addChild(marker)
            
        }
        
        connect(piece: marker, to: lastConnectedPiece)
    }
    
    // MARK: - Piece Templates -
    
    /// Adds an entity for a piece key.
    public func add(template: Entity, for key: TilePieceKey) {
        pieceTemplates[key] = template
    }
    
    /// Returns an entity that corresponds to a piece key.
    public func template(for key: TilePieceKey) -> Entity? {
        return pieceTemplates[key]
    }
    
    /// Makes sure two track pieces are exactly aligned, and that each has a reference to the other
    /// so the code can chain through the track pieces in order.
    func connect(piece: Entity, to otherPiece: Entity) {
        guard let lastConnectionOut = otherPiece.outConnection,
              let inConnection = piece.inConnection,
              let outConnectionVectorEntity = otherPiece.findEntity(named: SwiftSplashTrackPieces.outConnectionVectorName),
              let inConnectionVectorEntity = piece.findEntity(named: SwiftSplashTrackPieces.inConnectionVectorName),
              isDragging == false,
              isRotating == false,
              isSnapping == false else {
            return
        }
        
        // Calculate the orientation of the piece the app's connecting to.
        var lastPieceOrientation = otherPiece.sceneOrientation.normalized
        
        // Quaternions can store many rotation values in two different ways. For example, 270° around the Y
        // axis is the same as 90° around the negative Y axis. When this code encounters a rotation around a
        // negative axis, it flips it to keep everything consistent.
        if lastPieceOrientation.axis.y < 0 {
            lastPieceOrientation = simd_negate(lastPieceOrientation)
        }
        
        // If it's very close to 360°, snap to 360, which is actually 0°.
        // The ==~ operator is an "approximately equal to" comparison defined
        // in an extension in the SwiftSplashTrackPieces package. Note: this
        // is not a general purpose nearly equals operator; it uses an episilon value
        // tuned for this app's use cases.
        if lastPieceOrientation.angle ==~ (Float.pi * 2) {
            lastPieceOrientation = simd_quatf(angle: 0, axis: lastPieceOrientation.axis)
        }
        
        // Get the angle between the inverse of the out vector and the in vector.
        let outVector = simd_normalize(outConnectionVectorEntity.position)
        let invertedOutVector = simd_normalize(outVector * -1)
        let inVector = simd_normalize(inConnectionVectorEntity.position)
        
        var vectorRotationAngle = simd_quatf(from: inVector, to: invertedOutVector).normalized
        
        // When creating a quaternion from two angles, if they are 180°, the sample can't determine the axis
        // because 180° on any axis gives the same result. This tells it to use the Y axis.
        if vectorRotationAngle.angle ==~ Float.pi {
            vectorRotationAngle = simd_quatf(angle: Float.pi, axis: SIMD3<Float>.up)
        }
        
        // Combine the orientation of the last piece with the angle between the in and out vectors.
        var newRotation = (vectorRotationAngle * lastPieceOrientation).normalized
        var newRotationAngle = newRotation.angle
        
        // Snap to exactly 90° increments.
        if newRotationAngle.isNaN || newRotationAngle.isInfinite {
            newRotationAngle = 0
        }
        let divisor: Int = Int(round(newRotationAngle / pi_2))
        if divisor != 0 {
            newRotationAngle = pi_2 * Float(divisor)
        }
        
        // At exactly 180°, the sample can't determine the axis so returns NaN. When that happens,
        // tell it to use the Y axis since the piece only rotates on Y.
        if newRotation.axis.x.isNaN ||
            newRotation.axis.y.isNaN ||
            newRotation.axis.z.isNaN {
            newRotation = simd_quatf(angle: newRotationAngle, axis: SIMD3<Float>.up)
        } else {
            newRotation = simd_quatf(angle: newRotationAngle, axis: newRotation.axis)
        }
        
        // Set the new piece's rotation to the calculated amount.
        piece.sceneOrientation = newRotation
        
        // Calculate the distance between the connection points and move the piece by that much to make sure
        // the pieces are flush.
        let distanceVector = (lastConnectionOut.scenePosition - inConnection.scenePosition)
        piece.scenePosition += distanceVector
        
        if piece != placePieceMarker {
            piece.connectableStateComponent?.previousPiece = otherPiece
            otherPiece.connectableStateComponent?.nextPiece = piece
        }
    }
    
    /// Adds a specified scene to the RealityView.
    @discardableResult
    public func addEntityToScene(for key: TilePieceKey, material: MaterialType = .metal) -> Entity {
        guard let piece = pieceTemplates[key]?.clone(recursive: true) else {
            fatalError("Requested new entity of a type that doesn't exist.")
        }
        root.addChild(piece)
        piece.connectableStateComponent?.material = selectedMaterialType
        piece.updateTrackPieceAppearance()
        updateConnections()
        updateSelection()
        updatePower()
        if let lastPiece = lastConnectedPiece {
            placeMarker(at: lastPiece)
        }

        if let lastConnectedPiece = lastConnectedPiece, lastConnectedPiece != goalPiece {
            // Handle adding the piece to the end of the existing track.
            connect(piece: piece, to: lastConnectedPiece)
        } else {
            if let goalPiece = goalPiece {
                var newPosition = goalPiece.scenePosition
                newPosition.x += Float.random(in: -0.5...0.5)
                newPosition.z += Float.random(in: -0.5...0.5)
                newPosition.y += Float.random(in: -0.05...0.05)
                piece.scenePosition = newPosition
            }
        }
        updateMarkerPosition()
        updatePower()
        SoundEffect.placePiece.play(on: piece)
        piece.setUpAnimationVisibility()
        return piece
    }
    
    /// Sets a piece to use as the start point. Only one start point can exist at a time,
    /// so calling this a second time removes the previous piece.
    public func setStartPiece(_ entity: Entity) {
        startPiece?.removeFromParent()
        startPiece = entity
    }

    /// Sets a piece to use as the goal point. Only one goal point can exist at a time,
    /// so calling this a second time replaces the previous goal piece.
    public func setGoalPiece(_ entity: Entity) {
        goalPiece?.removeFromParent()
        goalPiece = entity
    }
    
    /// Adds the goal piece to the end of the track.
    public func addGoalPiece() {
        if let lastConnectedPiece = lastConnectedPiece,
           let goalPiece = goalPiece {
            root.addChild(goalPiece)
            connect(piece: goalPiece, to: lastConnectedPiece)
            goalPiece.connectableStateComponent?.material = selectedMaterialType
            goalPiece.updateTrackPieceAppearance()
            SoundEffect.placePiece.play(on: goalPiece)
            updateSelection()
            updateConnections()
        }
    }
    
    /// Removes the goal piece from the end of the track.
    public func removeGoalPiece() {
        goalPiece?.connectableStateComponent?.previousPiece?.connectableStateComponent?.nextPiece = nil
        goalPiece?.connectableStateComponent?.previousPiece = nil
        goalPiece?.connectableStateComponent?.isSelected = false
        goalPiece?.removeFromParent()
    }
    
    /// Hides the next piece position marker.
    public func hideMarkerPiece() {
        placePieceMarker?.isEnabled = false
    }
    
    /// Shows the next piece position marker.
    public func showMarkerPiece() {
        placePieceMarker?.isEnabled = true
    }
    
    /// Calculates the initial position of the start piece. On device, this uses head pose and calculates a position in front of the
    /// player. In simulator, the head pose is not available, so this hardcodes a position that's in front of the camera.
    public func setStartPieceInitialPosition() {
        
        guard let startPiece = startPiece else {
            fatalError("Attempting to place start piece, but no start piece exists.")
        }
        #if targetEnvironment(simulator)
        startPiece.position.y = 1.05
        startPiece.position.z = -1
        #else
        guard let pose = worldInfo.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else {
            startPiece.position.y = 1.05
            startPiece.position.z = -1
            return
        }
        let cameraMatrix = pose.originFromAnchorTransform
        let cameraTransform = Transform(matrix: cameraMatrix)
        startPiece.position = cameraTransform.translation + cameraMatrix.forward * -0.5
        #endif
    }
    
    /// Resets the state of the RealityView. Used when going back to the main menu from building or running the ride.
    public func resetBoard() {
        guard let startPiece = startPiece else {
            fatalError("Trying to reset board, but there's no start piece.")
        }
        guard let goalPiece = goalPiece else {
            fatalError("Trying to reset board, but there's no goal piece.")
        }
        goalPiece.removeFromParent()
        additionalSelectedTrackPieces.removeAll()
        trackPieceBeingEdited = nil
        
        let entities = root.scene?.performQuery(connectableQuery)
        
        entities?.forEach { entity in
            if entity != startPiece {
                while entity.parent != nil {
                    entity.removeFromParent()
                }
            }
        }
        startPiece.connectableStateComponent?.isSelected = false
        startPiece.updateTrackPieceAppearance()
        updateConnections()

    }
  
    /// Checks to make sure a connectable entity has an initialized state component. The app adds the `ConnectableStateComponent`
    /// in code for all entities with a `ConnectableComponent`so that the internal state properties don't show up in Reality Composer Pro's inspector.
    public func setupConnectable(entity: Entity) {
        // Store connection points.
        if entity.connectableStateComponent == nil {
            logger.info("Adding state component to \(entity.name).")
            var state = ConnectableStateComponent()
            state.inConnection = entity.descendants(containingSubstring: inConnectionName).first
            state.outConnection = entity.descendants(containingSubstring: outConnectionName).first
            state.entity = entity
            state.isPowered = false
            state.material = selectedMaterialType
            entity.connectableStateComponent = state
            entity.components.set(state)
            entity.updateTrackPieceAppearance()
        }
    }
    
    /// Looks around the piece for the closest other connectable piece to each of its connection points and updates the next and previous links
    /// on its state component.
    public func findClosestPieces(for entity: Entity) {
        let possibleIn = findNearestConnectionPoint(entity: entity, connectionType: .inPoint)
        if possibleIn.distance < maximumConnectionDistance {
            entity.connectableStateComponent?.previousPiece = possibleIn.closestEntity
        } else {
            entity.connectableStateComponent?.previousPiece = nil
        }
        let possibleOut = findNearestConnectionPoint(entity: entity, connectionType: .outPoint)
        if possibleOut.distance < maximumConnectionDistance {
            entity.connectableStateComponent?.nextPiece = possibleOut.closestEntity
        } else {
            entity.connectableStateComponent?.nextPiece = nil
        }
    }
    
    public func addHoverEffectToConnectables() {
        let entities = root.scene?.performQuery(connectableQuery)
        
        entities?.forEach { entity in
            entity.components.set(HoverEffectComponent())
        }
    }
    
    public func removeHoverEffectFromConnectibles() {
        let entities = root.scene?.performQuery(connectableQuery)
        
        entities?.forEach { entity in
            entity.components[HoverEffectComponent.self] = nil
        }
    }
    
    public enum RotateDirection {
        case clockwise, counterClockwise
    }
    
    public func rotateSelectedEntities(direction: RotateDirection = .clockwise) {
        guard let trackPieceBeingEdited = trackPieceBeingEdited else { return }
        let rotationAmount = (direction == .clockwise) ? Float.pi / 2 : -Float.pi / 2
        if additionalSelectedTrackPieces.isEmpty {
            trackPieceBeingEdited.sceneOrientation *= simd_quatf(angle: Float(rotationAmount), axis: SIMD3<Float>.up)
            trackPieceBeingEdited.sceneOrientation = trackPieceBeingEdited.sceneOrientation.normalized
        } else {
            let parentEntity = Entity()
            root.addChild(parentEntity)
            parentEntity.scenePosition = selectedTrackRotationPoint
            trackPieceBeingEdited.setParent(parentEntity, preservingWorldTransform: true)
            for entity in additionalSelectedTrackPieces {
                entity.setParent(parentEntity, preservingWorldTransform: true)
            }
            parentEntity.sceneOrientation *= simd_quatf(angle: Float(rotationAmount), axis: SIMD3<Float>.up)
            parentEntity.sceneOrientation = parentEntity.sceneOrientation.normalized
            trackPieceBeingEdited.setParent(root, preservingWorldTransform: true)
            for entity in additionalSelectedTrackPieces {
                entity.setParent(root, preservingWorldTransform: true)
            }
            parentEntity.removeFromParent()
        }
    }
}

----!@#$----
SwiftSplash/Data & State/AppState+Transparency.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to manually sorting transparent objects to ensure correct rendering.
*/

import ARKit
import Combine
import Foundation
import RealityKit
import SwiftSplashTrackPieces
import UIKit

public extension AppState {
    
    /// Utility function that adds a model sort group component to an entity.
    fileprivate func setEntityDrawOrder(_ entity: Entity, _ sortOrder: Int32, _ sortGroup: ModelSortGroup) {
        entity.forEachDescendant(withComponent: ModelComponent.self) { modelEntity, model in
            logger.info("Setting sort order of \(sortOrder) of \(entity.name), child entity: \(modelEntity.name)")
            let component = ModelSortGroupComponent(group: sortGroup, order: sortOrder)
            modelEntity.components.set(component)
        }
    }
    
    /// Manually specifies sort ordering for the transparent start piece meshes.
    func handleStartPieceTransparency(_ startPiece: Entity) {
        let group = ModelSortGroup()
        
        // Opaque fish parts.
        if let entity = startPiece.findEntity(named: fishIdleAnimModelName) {
            setEntityDrawOrder(entity, 1, group)
        }
        if let entity = startPiece.findEntity(named: fishRideAnimModelName) {
            setEntityDrawOrder(entity, 2, group)
        }
        
        // Transparent fish parts.
        if let entity = startPiece.findEntity(named: fishGlassIdleAnimModelName) {
            setEntityDrawOrder(entity, 3, group)
        }
        if let entity = startPiece.findEntity(named: fishGlassRideAnimModelName) {
            setEntityDrawOrder(entity, 4, group)
        }
        
        // Water.
        if let entity = startPiece.findEntity(named: sortOrderWaterName) {
            setEntityDrawOrder(entity, 5, group)
        }
        
        // Glass globe.
        if let entity = startPiece.findEntity(named: sortOrderGlassGlobeName) {
            setEntityDrawOrder(entity, 6, group)
        }
        
        // Selection glow.
        if let entity = startPiece.findEntity(named: startGlowName) {
            setEntityDrawOrder(entity, 7, group)
        }
    }
    
    /// Manually specifies sort ordering for transparent track pieces.
    func handleTrackPieceTransparency(_ trackPiece: Entity) {

        // Find opaque fish parts and set sort order to 1.
        trackPiece.forEachDescendant(withSuffix: sortOrderFishGlassSuffix) { entity in
            setEntityDrawOrder(entity, 1, trackPieceSortOrderGroup)
        }
        
        // Find transparent fish parts and set sort order to 2.
        trackPiece.forEachDescendant(withSuffix: sortOrderFishSuffix) { entity in
            setEntityDrawOrder(entity, 2, trackPieceSortOrderGroup)
        }
        
        // Find water parts and set sort order to 3.
        trackPiece.forEachDescendant(withSuffix: sortOrderWaterSuffix) { entity in
            setEntityDrawOrder(entity, 3, trackPieceSortOrderGroup)
        }
        
        // Find the bottom track piece and set sort order to 4.
        trackPiece.forEachDescendant(withSuffix: sortOrderTrackBottomSuffix) { entity in
            setEntityDrawOrder(entity, 4, trackPieceSortOrderGroup)
        }
        
        // Find the glass top piece and set sort order to 5.
        trackPiece.forEachDescendant(withSuffix: sortOrderTrackTopsuffix) { entity in
            setEntityDrawOrder(entity, 5, trackPieceSortOrderGroup)
        }
        
        // Find the bottom track piece and set sort order to 6.
        trackPiece.forEachDescendant(withSuffix: sortOrderTrackBottomGlowSuffix) { entity in
            setEntityDrawOrder(entity, 6, trackPieceSortOrderGroup)
        }
        
        // Find the top glow piece and set sort order to 7.
        trackPiece.forEachDescendant(withSuffix: sortOrderTrackGlowSuffix) { entity in
            setEntityDrawOrder(entity, 7, trackPieceSortOrderGroup)
        }
    }
    
    /// Manually specifies sort ordering for the transparent goal piece meshes.
    func handleEndPieceTransparency(_ endPiece: Entity) {
        let group = ModelSortGroup()
        
        if let entity = endPiece.findEntity(named: sortOrderEndWaterName) {
            setEntityDrawOrder(entity, 1, group)
        }
        if let entity = endPiece.findEntity(named: sortOrderEndSlideName) {
            let component = ModelSortGroupComponent(group: group, order: 2)
            entity.components.set(component)
        }
        if let entity = endPiece.findEntity(named: sortOrderEndSlideTopName) {
            setEntityDrawOrder(entity, 3, group)
        }
    }
}

----!@#$----
SwiftSplash/Data & State/AppState+PieceLoading.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that holds application state functions related to loading slide pieces from Reality Composer Pro.
*/

import ARKit
import Combine
import Foundation
import RealityKit
import SwiftSplashTrackPieces
import UIKit

actor EntityContainer {
    var entity: Entity?
    func setEntity(_ newEntity: Entity?) {
        entity = newEntity
    }
}

struct LoadResult: Sendable {
    var entity: Entity
    var key: String
}

extension AppState {
    /// Loads a named entity and its descendants from a Reality Composer Pro scene.
    private func loadFromRCPro(named entityName: String,
                               fromSceneNamed sceneName: String,
                               scaleFactor: Float? = nil) async throws -> Entity? {
        
        var ret: Entity? = nil
        logger.info("Loading entity \(entityName) from Reality Composer Pro scene \(sceneName)")
        do {
            let scene = try await Entity(named: sceneName, in: SwiftSplashTrackPieces.bundle)
            let entityContainer = EntityContainer()
            let theRet = scene.findEntity(named: entityName)
            if let scaleFactor = scaleFactor {
                theRet?.scale = SIMD3<Float>(repeating: scaleFactor)
            }
            await entityContainer.setEntity(theRet)
            ret = await entityContainer.entity
        } catch {
            fatalError("\tEncountered fatal error: \(error.localizedDescription)")
        }
        return ret
    }
    
    /// Loads the track pieces.
    public func loadPieces() async {
        defer {
            finishedLoadingAssets()
        }
        let startTime = Date.timeIntervalSinceReferenceDate
        logger.info("Starting load from Reality Composer Pro Project.")
        finishedStartingUp()
        await withTaskGroup(of: LoadResult.self) { taskGroup in
            loadTrackPieces(taskGroup: &taskGroup)
            loadStartPiece(taskGroup: &taskGroup)
            loadGoalPiece(taskGroup: &taskGroup)
            loadPlacementMarker(taskGroup: &taskGroup)
            for await result in taskGroup {
                if let pieceKey = pieces.first(where: { $0.key.rawValue == result.key }) {
                    processLoadedTrackPiece(result: result, pieceKey: pieceKey)
                } else {
                    if result.key == startPieceName {
                        processLoadedStartPiece(result: result)
                    } else if result.key == endPieceName {
                        processLoadedGoalPiece(result: result)
                    } else if result.key == placePieceMarkerName {
                        self.placePieceMarker = result.entity
                        self.updateMarkerPosition()
                    }
                }
            }
            logger.info("Load of pieces completed. Duration: \(Date.timeIntervalSinceReferenceDate - startTime)")
        }
    }
    
    /// This function sets up the regular track pieces after load.
    private func processLoadedTrackPiece(result: LoadResult, pieceKey: Piece) {
        self.add(template: result.entity, for: pieceKey.key)
        setupConnectable(entity: result.entity)
        result.entity.components.set(HoverEffectComponent())
        result.entity.setUpAnimationVisibility()
        handleTrackPieceTransparency(result.entity)
        result.entity.setWaterLevel(level: 0)
        result.entity.adjustCollisionBox(scaleBy: [1.0, 0.5, 1.0], offsetBy: [0, 0, 0])
    }
    
    /// This function sets up the start piece after load.
    private func processLoadedStartPiece(result: LoadResult) {
        self.setStartPiece(result.entity)
        result.entity.setWaterLevel(level: 0)
        result.entity.setUpAnimationVisibility()
        result.entity.components.set(HoverEffectComponent())
        setStartPiece(result.entity)
        setStartPieceInitialPosition()
        setupConnectable(entity: result.entity)
        result.entity.playIdleAnimations()
        handleStartPieceTransparency(result.entity)
        result.entity.adjustCollisionBox(scaleBy: [1.0, 0.9, 0.8], offsetBy: [0, 0.1, 0.038])
        
        self.placeMarker(at: result.entity)
        result.entity.connectableStateComponent?.isSelected = false
        clearSelection()
        updateSelection()
    }
    
    /// This function sets up the goal piece after load.
    private func processLoadedGoalPiece(result: LoadResult) {
        self.setGoalPiece(result.entity)
        setupConnectable(entity: result.entity)
        result.entity.components.set(HoverEffectComponent())
        setGoalPiece(result.entity)
        result.entity.setUpAnimationVisibility()
        result.entity.setWaterLevel(level: 0)
        handleEndPieceTransparency(result.entity)
        result.entity.adjustCollisionBox(scaleBy: [0.95, 0.485, 0.8], offsetBy: [0, 0.11, -0.045])
    }
    
    /// This function loads the regular track pieces (everything except the start and end piece and the placement marker).
    private func loadTrackPieces(taskGroup: inout TaskGroup<LoadResult>) {
        // Load the regular track pieces and ride animations.
        logger.info("Loading track pieces.")
        for piece in pieces {
            taskGroup.addTask {
                do {
                    guard let pieceEntity = try await self.loadFromRCPro(named: piece.key.rawValue,
                                                                         fromSceneNamed: piece.sceneName,
                                                                         scaleFactor: 1.5) else {
                        fatalError("Attempted to load piece entity \(piece.name) but failed.")
                    }
                    return LoadResult(entity: pieceEntity, key: piece.key.rawValue)
                } catch {
                    fatalError("Attempted to load \(piece.name) but failed: \(error.localizedDescription)")
                }
            }
        }
    }
    
    /// This function loads the start piece from the Reality Compoer Pro project.
    private func loadStartPiece(taskGroup: inout TaskGroup<LoadResult>) {
        taskGroup.addTask {
            var result: Entity? = nil
            do {
                logger.info("Loading start piece.")
                if let entity = try await self.loadFromRCPro(named: startPieceName,
                                                             fromSceneNamed: SwiftSplashTrackPieces.startPieceSceneName,
                                                             scaleFactor: 1.5) {
                    result = entity
                }
            } catch {
                fatalError("Attempted to load start entity but failed: \(error.localizedDescription)")
            }
            guard let result = result else {
                fatalError("Loaded start piece is nil")
            }
            return LoadResult(entity: result, key: startPieceName)
        }
    }
    
    /// This function loads the goal piece from the Reality Composer Pro project.
    private func loadGoalPiece(taskGroup: inout TaskGroup<LoadResult>) {
        taskGroup.addTask {
            var result: Entity? = nil
            do {
                logger.info("Loading goal piece.")
                // Load the end piece.
                if let goalPiece = try await self.loadFromRCPro(named: endPieceName, fromSceneNamed: endPieceSceneName, scaleFactor: 1.5) {
                    result = goalPiece
                }
            } catch {
                fatalError("Attempted to load goal entity but failed: \(error.localizedDescription)")
            }
            guard let result = result else {
                fatalError("Loaded start piece is nil.")
            }
            return LoadResult(entity: result, key: endPieceName)
        }
    }
    
    private func loadPlacementMarker(taskGroup: inout TaskGroup<LoadResult>) {
        taskGroup.addTask {
            var result: Entity?
            do {
                logger.info("Loading next piece placement marker.")
                // Load the marker that shows where the next piece will go.
                if let placementMarker = try await self.loadFromRCPro(named: placePieceMarkerName, fromSceneNamed: placePieceMarkerSceneName) {
                    result = placementMarker
                }
            } catch {
                fatalError("Attempted to load piece placement marker entity but failed: \(error.localizedDescription)")
            }
            guard let result = result else {
                fatalError("Loaded start piece is nil")
            }
            return LoadResult(entity: result, key: placePieceMarkerName)
        }
    }
}

----!@#$----
SwiftSplash/Data & State/AppConfig.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Configuration values and global variables.
*/

import Foundation
import OSLog
import RealityKit

/// Indicate how close two compatible connection points have to be
/// in order for power to be transferred.
let maximumConnectionDistance = Float(0.01)

/// Indicate how close two compatible connection points have to be
/// in order to snap.
let maximumSnapDistance = Float(0.14)

/// The app doesn't continue snapping pieces forever. Constantly snapping pieces could
/// result in weird interactions when connection points are close.
var secondsAfterDragToContinueSnap = TimeInterval(0.025)

/// The piece being dragged or rotated using gesture entities.
var draggedPiece: Entity? = nil

/// The speed of the ride animations as a multiplier of the original animation in the USDZ file.
let animationSpeedMultiplier = Double(1.0)

/// Indicate how close two connection points must be to be considered connected.
let snapEpsilon = 0.000_000_1

/// Set this to true to tell the ride animation code that it should stop.
var shouldCancelRide = false

/// Set this to true to pause the current ride animation.
var shouldPauseRide = false

/// If `shouldPauseRide` is `true`, this identifies when the pause started.
var pauseStartTime: TimeInterval = 0

/// Use to keep a reference to ride animations.
var rideAnimationcontrollers = [AnimationPlaybackController]()

/// Indicate how long it takes to snap rotation to the nearest 90°. The maximum snap rotation
/// is 45°, so this value represents how long it takes to snap rotate 45°.
var rotateSnapTime: TimeInterval = 10

/// Water should not flow until the doors open. The app uses this to determine
/// when to start the water flowing after the start piece animations start
var waterStartDelay: TimeInterval = 9.6

/// The fish starts making ambient sounds after the ride runs for this long.
var ambientSoundsDelay: TimeInterval = 17.0

var rotatingParentNodeName = "Rotating Parent"

/// When someone is dragging one or more track pieces using a gesture, this is `true`.
var isDragging = false

/// When someone is rotating one or more track pieces using a gesture, this is `true`.
var isRotating = false

var isSnapping = false

----!@#$----
SwiftSplash/Preview Content/Preview Assets.xcassets/Contents.json
{
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

----!@#$----
SwiftSplash/Extensions/Date+Logging.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension that formats dates for logging.
*/
import Foundation

extension Date {
    static public var timestamp: String {
        let dateFMT = DateFormatter()
        dateFMT.locale = Locale(identifier: "en_US_POSIX")
        dateFMT.dateFormat = "yyyyMMdd'T'HHmmss.SSSS"
        let now = Date()
        
        return String(format: "%@", dateFMT.string(from: now))
    }
}

----!@#$----
SwiftSplash/Extensions/Entity+SwiftSplash.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on Entity containing app-specific functions.
*/

import Foundation
import SwiftSplashTrackPieces
import RealityKit

public extension Entity {
    
    /// Sets visibility for animation entities for build mode and for ride mode when this piece isn't the active ride piece.
    func setUpAnimationVisibility() {
        forEachDescendant(withComponent: IdleAnimationComponent.self) { entity, component in
            // Only the start piece shows idle animations during build mode.
            entity.isEnabled = self.name == startPieceName
        }
        
        forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
            entity.isEnabled = component.isPersistent
        }
        
        forEachDescendant(withComponent: GlowComponent.self) { entity, component in
            guard let isSelected = connectableStateComponent?.isSelected,
                  let material = connectableStateComponent?.material else { return }
            if component.isTopPiece && material == .metal {
                entity.isEnabled = true
            }
            entity.isEnabled = isSelected
        }
        forEachDescendant(withComponent: RideWaterComponent.self) { entity, component in
            entity.setWaterLevel(level: 0.0)
        }
    }
    
    /// Sets visibility for animation entities for when this piece is active during the ride.
    func setVisibilityForTrackStart() {
        forEachDescendant(withComponent: IdleAnimationComponent.self) { entity, component in
            entity.isEnabled = false
        }
        
        forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
            entity.isEnabled = true
        }
    }
    
    func setWaterLevel(level: Float) {
        isEnabled = true
        
        func setWaterlevelOnMaterials(_ modelEntity: Entity, _ modelComponent: ModelComponent, _ level: Float) {
            modelEntity.isEnabled = level > 0
            var modelComponent = modelComponent
            modelComponent.materials = modelComponent.materials.map {
                guard var material = $0 as? ShaderGraphMaterial else { return $0 }
                if material.parameterNames.contains(waterLevelParameterName) {
                    do {
                        try material.setParameter(name: waterLevelParameterName,
                                                  value: MaterialParameters.Value.float(level))
                    } catch {
                        logger.error("Error setting ride_running material parameter: \(error.localizedDescription)")
                    }
                }
                return material
            }
            modelEntity.modelComponent = modelComponent
        }
        
        forEachDescendant(withComponent: RideWaterComponent.self) { entity, component in
            if let modelComponent = entity.modelComponent {
                setWaterlevelOnMaterials(entity, modelComponent, level)
            }
            entity.forEachDescendant(withComponent: ModelComponent.self) { modelEntity, component in
                setWaterlevelOnMaterials(modelEntity, component, level)
            }
        }
    }
    
    func hideAllIdleAndNonPersistentAnimations() {
        forEachDescendant(withComponent: IdleAnimationComponent.self) { entity, component in
            entity.isEnabled = component.playAtEndInsteadOfBeginning
            if component.playAtEndInsteadOfBeginning {
                entity.playIdleAnimations()
            }
        }
        
        forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
            if !component.isPersistent {
                entity.isEnabled = false
            }
        }
    }
    
    /// Recursively plays all animations on this entity and all descendant entities.
    func playRideAnimations() {
        setVisibilityForTrackStart()
        var animDuration: Double = 0
        forEachDescendant(withComponent: RideAnimationComponent.self) { entity, component in
            if component.duration > animDuration {
                animDuration = component.duration / animationSpeedMultiplier
            }
            for animation in entity.availableAnimations {
                var animation = animation
                
                if component.alwaysAnimates {
                    animation = animation.repeat(count: Int.max)
                }
                
                let controller = entity.playAnimation(animation, transitionDuration: 0.0, startsPaused: false)
                rideAnimationcontrollers.append(controller)
                controller.resume()
                controller.speed = Float(animationSpeedMultiplier)
            }
        }
        Task(priority: .high) {
            await loopThroughRidePieces(animDuration: animDuration)
        }
    }
    
    private func loopThroughRidePieces(animDuration: Double) async {
        var rideStartTime: TimeInterval = Date.timeIntervalSinceReferenceDate
        var adjustedStartTime = rideStartTime
        
        var later = Date.timeIntervalSinceReferenceDate
        while later - adjustedStartTime < animDuration {
            // Keep sleep duration to less than one frame for precision (90fps = 11.11111ms).
            try? await Task.sleep(for: .milliseconds(11))
            if shouldCancelRide { return }
            later = Date.timeIntervalSinceReferenceDate
            
            if shouldPauseRide {
                handleRidePause(adjustedStartTime: &adjustedStartTime, rideStartTime: &rideStartTime)
            } else {
                if rideStartTime > 0 {
                    for controller in rideAnimationcontrollers {
                        controller.resume()
                    }
                    pauseStartTime = 0
                    rideStartTime = adjustedStartTime
                }
            }
        }

        if shouldCancelRide { return }
        if let nextPiece = self.connectableStateComponent?.nextPiece, nextPiece.name == "end" {
            handleNextEndPiece()
            handleEndPiece()

        }
        
        if shouldCancelRide { return }
        self.hideAllIdleAndNonPersistentAnimations()
        
        // Check if there's another piece after this one.
        guard let nextPiece = self.connectableStateComponent?.nextPiece else {
            return
        }
        if shouldCancelRide { return }
        // See if there's another piece connected after this one.
        logger.info("Triggering animation from \(self.name) on \(nextPiece.name) at \(Date.timestamp)")
        nextPiece.playRideAnimations()
    }
    
    private func handleEndPiece() {
        // Stop playing idle sounds.
        SoundEffect.stopLoops(for: nil)
        
        guard let endPiece = self.connectableStateComponent?.nextPiece else { fatalError("Next piece is not the end piece.") }
        
        endPiece.setAllParticleEmittersTo(to: true, except: [waterFallParticlesName, fishSplashParticleName])
        Task {
            try await Task.sleep(for: .seconds(1))
            endPiece.makeFishSplash()
            try await Task.sleep(for: .seconds(9))
            endPiece.setAllParticleEmittersTo(to: false, except: [waterFallParticlesName, fishSplashParticleName])
        }
    }
    
    private func handleRidePause(adjustedStartTime: inout TimeInterval, rideStartTime: inout TimeInterval ) {
        if pauseStartTime == 0 {
            pauseStartTime = Date.timeIntervalSinceReferenceDate
        }
        for controller in rideAnimationcontrollers {
            controller.pause()
        }
        adjustedStartTime = rideStartTime + Date.timeIntervalSinceReferenceDate - pauseStartTime
    }
    
    private func handleNextEndPiece() {
        SoundEffect.stopLoops(for: nil)
        SoundEffect.stopLoops(for: .fishDrop)
        SoundEffect.fishSucceed.play(on: self)
    }
 
    /// Sets all particle systems contained in this entity's hierarchy on or off.
    func setAllParticleEmittersTo(to isOn: Bool, except emittersToIgnore: [String] = [String]()) {
        self.forEachDescendant(withComponent: ParticleEmitterComponent.self) { entity, component in
            guard !emittersToIgnore.contains(entity.name) else { return }
            logger.info("Turning emitter on entity \(entity.name) to \(isOn)")
            var component = component
            component.isEmitting = isOn
            component.simulationState = (isOn) ? .play : .stop
            if isOn {
                entity.isEnabled = true
            } else {
                Task {
                    // Give the particles that have already been emitted a chance to finish.
                    try await Task.sleep(for: .seconds(4))
                    entity.isEnabled = false
                }
            }
            entity.components.set(component)
        }
    }
    
    func stopAllParticleEmittersEmitting(except emittersToIgnore: [String] = [String]()) {
        self.forEachDescendant(withComponent: ParticleEmitterComponent.self) { entity, component in
            guard !emittersToIgnore.contains(entity.name) else { return }
            logger.info("Turning off emission of particles on entity \(entity.name).")
            var component = component
            component.isEmitting = false
            entity.components.set(component)
        }
    }
    
    func makeFishSplash() {
        guard let splashParticlesEntity = findEntity(named: fishSplashParticleName),
              var splashParticlesComponent = splashParticlesEntity.particleEmitterComponent else { return }
        splashParticlesComponent.isEmitting = true
        splashParticlesComponent.simulationState = .play
        splashParticlesEntity.components.set(splashParticlesComponent)
        isEnabled = true
    }
    
    func stopWaterfall() {
        self.forEachDescendant(withComponent: ParticleEmitterComponent.self) { entity, component in
            var component = component
            component.isEmitting = false
            component.simulationState = .stop
            entity.components.set(component)
            entity.isEnabled = false
        }
    }
    
    func disableAllParticleEmitters(except emittersToIgnore: [String] = [String]()) {
        Task(priority: .high) {
            stopAllParticleEmittersEmitting(except: emittersToIgnore)
            try? await Task.sleep(for: .seconds(3))
            setAllParticleEmittersTo(to: false, except: emittersToIgnore)
        }
    }
    
    /// Plays idle animations so they loop.
    func playIdleAnimations() {
        forEachDescendant(withComponent: IdleAnimationComponent.self) { entity, component in
            for animation in entity.availableAnimations {
                logger.info("Found idle animation: \(String(describing: animation.name))")
                let animation = animation.repeat(count: Int.max)
                let controller = entity.playAnimation(animation, transitionDuration: 0.0, startsPaused: false)
                controller.resume()
            }
        }
    }
    
    func adjustCollisionBox(scaleBy: SIMD3<Float>, offsetBy: SIMD3<Float>) {
        if var component = collisionComponent {
            if let shape = component.shapes.first {
                let calculatedBounds = shape.bounds
                let newBoxOffset = ShapeResource.generateBox(width: calculatedBounds.extents.x * scaleBy.x,
                                                             height: calculatedBounds.extents.y * scaleBy.y,
                                                             depth: calculatedBounds.extents.z * scaleBy.z)
                let newBox = newBoxOffset.offsetBy(translation: offsetBy)
                
                component.shapes.removeAll()
                component.shapes.append(newBox)
            }
            components.set(component)
        }
    }
}

----!@#$----
SwiftSplash/Views/SplashScreenView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view holding the app's splash screen.
*/
import RealityKit
import SwiftUI
struct SplashScreenView: View {
    @Environment(AppState.self) var appState
    
    var body: some View {
        VStack {
            Text("Swift Splash")
                .font(.extraLargeTitle2)
                .fontWeight(.bold)
            Text("Build an epic water ride this adventurous fish won’t forget.")
                .frame(width: 300)
                .font(.system(size: 18))
                .fontWeight(.bold)
                .multilineTextAlignment(.center)
                .padding(.top, -5)
                .padding(.bottom, 10)
                
            if appState.phase == .loadingAssets {
                ProgressView("Loading Assets…")
            } else {
                Button("Start Building") {
                    appState.startBuilding()
                }
                .accessibilityElement()
            }
        }
        .offset(y: 100)
        .frame(maxWidth: 600, maxHeight: 440, alignment: .center)
        .background {
            Image("swiftSplashHero")
                .resizable()
                .aspectRatio(contentMode: .fit)
                .offset(y: -110)
        }
        .onAppear {
            // Play menu music as content loads.
            appState.music = .menu
        }
    }
}
#Preview {
    SplashScreenView()
        .glassBackgroundEffect()
        .environment(AppState())
}

----!@#$----
SwiftSplash/Views/TrackBuildingView+Rotation.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on the track-building view that contains functions related to rotating slide pieces.
*/

import SwiftUI
import RealityKit
import SwiftSplashTrackPieces
import simd

struct RotateSnapInfo: Sendable {
    let entity: Entity
    let startDegrees: Double
    let destinationDegrees: Double
    let startTime: TimeInterval
}

extension TrackBuildingView {
    
    /// Creates a parent entity for rotation and place it at the correct pivot point based on center
    /// of the combined bounding boxes of the selected pieces.
    @MainActor
    private func createRotationParent(for entity: Entity) {
        
        rotationParent = Entity()
        rotationParent?.name = rotatingParentNodeName
        if let rotationParent = rotationParent {
            appState.setupConnectable(entity: rotationParent)
        }

        if let rotationParent = rotationParent {
            appState.root.addChild(rotationParent)
        }
        rotationParent?.scenePosition = appState.selectedTrackRotationPoint
        
        if let trackPieceBeingEdited = appState.trackPieceBeingEdited {
            trackPieceBeingEdited.setParent(rotationParent, preservingWorldTransform: true)
        }
        for selectedPiece in appState.additionalSelectedTrackPieces {
            if let rotationParent = rotationParent {
                selectedPiece.setParent(rotationParent, preservingWorldTransform: true)
            }
        }
        entity.setParent(rotationParent, preservingWorldTransform: true)
        appState.updateSelection()
    }
    
    /// The logic to handle the input fom a rotation gesture.
    @MainActor
    func handleRotationChanged(_ value: EntityTargetValue<RotateGesture.Value>, isEnded: Bool = false) {
        guard !(isEnded == true && isSnapping == true) else { return }
        guard appState.phase == .buildingTrack || appState.phase == .placingStartPiece || appState.phase == .draggingStartPiece  else {
            logger.info("Wrong phase for rotation, returning.")
            isRotating = false
            return
        }
        guard let entity = value.entity.connectableAncestor else {
            logger.debug("Could not find a connectable component on gesture entity or its ancestors.")
            isRotating = false
            return
        }
        
        isRotating = true
        
        if appState.phase == .placingStartPiece {
            appState.startedDraggingStartPiece()
        }
        
        // If somebody rotates a piece that's not selected, clear the selection and select the dragged piece.
        if  rotatedEntity == nil {
            rotatedEntity = entity
            if appState.trackPieceBeingEdited == nil ||
                (appState.trackPieceBeingEdited != rotatedEntity && !appState.entityIsInAdditionalSelectedTrackPieces(rotatedEntity)) {
                appState.clearSelection()
                appState.trackPieceBeingEdited = rotatedEntity
                appState.trackPieceBeingEdited?.connectableStateComponent?.isSelected = true
            }
        }
        
        appState.editAttachment?.removeFromParent()

        // If there's only one selected track piece, rotate just that piece.
        if appState.additionalSelectedTrackPieces.isEmpty {
            if appState.trackPieceBeingEdited == nil {
                rotationParent = entity
            } else {
                rotationParent = appState.trackPieceBeingEdited
            }
        } else {
            // If there are multiple selected tracks, create a common parent to rotate.
            if rotationParent == nil {
               createRotationParent(for: entity)
            }
        }
        guard let rotationParent = rotationParent else {
            fatalError("App attempted to rotate object without rotation entity.")
        }
        setRotation(entity: rotationParent, radians: -value.gestureValue.rotation.radians, snap: isEnded)
        appState.updatePower()
        appState.updateConnections()
        appState.updateMarkerPosition()
    }
    
    /// Sets the rotation value for an entity being manipulated using the 3D rotation gesture.
    func setRotation(entity: Entity, radians: Double, snap: Bool = false) {
        // Increase rotation speed.
#if targetEnvironment(simulator)
        let radians = radians * 3
#else
        let radians = radians * 8
#endif
        // Retrieve the rotation value from when the gesture started.
        if let startAngleRadians = entity.connectableStateComponent?.startRotation {
            
            let startAngleDegrees = Angle(radians: startAngleRadians).degrees
            let angleDegrees = Angle(radians: radians).degrees + startAngleDegrees
            let angleRadians = Angle(degrees: angleDegrees).radians
            
            // Determine if there is another slide piece close enough to snap to, and
            // implement the snapping behavior.
            if snap && !isSnapping {
                
                var destinationDegrees = angleDegrees + 45
                destinationDegrees = Double(Int(floor(destinationDegrees / 90)) * 90)
                let info = RotateSnapInfo(entity: entity, startDegrees: angleDegrees,
                                          destinationDegrees: destinationDegrees,
                                          startTime: Date.timeIntervalSinceReferenceDate)
                
                // Each pass through the loop moves the dragged piece closer to the piece it's snapping to.
                Task(priority: .high) { @MainActor in
                    defer {
                        isRotating = false
                        Task {
                            try await Task.sleep(for: .seconds(0.25))
                            appState.showEditAttachment()
                        }
                    }
                    
                    try? await loopForSnap(info: info, entity: entity, radians: radians)

                    Task {
                        self.rotationParent?.removeFromParent()
                        self.rotationParent = nil
                        rotatedEntity = nil
                        if let attachmentPoint = appState.trackPieceBeingEdited?.uiAnchor,
                           let editAttachment = appState.editAttachment {
                            attachmentPoint.addChild(editAttachment)
                            
                        }
                        try await Task.sleep(for: .seconds(0.25))
                        isRotating = false
                    }
                    appState.updateMarkerPosition()
                }
                return
            }
            entity.sceneOrientation = simd_quatf(angle: Float(angleRadians), axis: SIMD3<Float>.up).normalized
        }
    }
    @MainActor
    private func loopForSnap(info: RotateSnapInfo,
                             entity: Entity,
                             radians: Double) async throws {
        var done = false
        while !done {
            try await Task.sleep(for: .milliseconds(11))
            let degreesToAdd = (Date.timeIntervalSinceReferenceDate - info.startTime) * (rotateSnapTime * 45)
            var newRotationDegrees = info.startDegrees + degreesToAdd
            if newRotationDegrees >= info.destinationDegrees {
                newRotationDegrees = info.destinationDegrees
                done = true
            }
            let newRotationRadians = Angle(degrees: newRotationDegrees).radians
            info.entity.sceneOrientation = simd_quatf(angle: Float(newRotationRadians), axis: SIMD3<Float>.up).normalized
        }
        
        if  self.rotationParent?.name != rotatingParentNodeName {
            self.rotationParent = nil
            isRotating = false
            return
        }
        
        if let parent = self.rotationParent {
            // Calling setParent on an child while iterating the children invalidates the iterator
            // so create a new array with the child entities and iterate that instead.
            let children = [Entity](parent.children)
            for child in children {
                child.setParent(appState.root, preservingWorldTransform: true)
                child.connectableStateComponent?.startRotation = 0
            }
        }
    }
}

----!@#$----
SwiftSplash/Views/PieceShelfTrackButtonsView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view holding buttons that add new slide pieces to the ride.
*/

import SwiftUI

struct PieceShelfTrackButtonsView: View {
    @Environment(AppState.self) var appState
    @State private var endPieceIsInRealityView = false
    
    let timer = Timer.publish(every: 0.01, on: .main, in: .common).autoconnect()
    
    var body: some View {
        Grid(horizontalSpacing: 20, verticalSpacing: 20) {
            GridRow {
                ImageButton(
                    title: "Simple Ramp",
                    imageName: appState.simpleRampImageName,
                    buttonAction: { button in
                        appState.clearSelection()
                        appState.addEntityToScene(for: .slide1, material: appState.selectedMaterialType)
                    }
                )
                .disabled(appState.phase != .buildingTrack)
                .accessibilityElement()
                .accessibilityLabel(Text("Add straight slide piece."))
                
                ImageButton(
                    title: "Right Turn",
                    imageName: appState.rightTurnImageName,
                    buttonAction: { button in
                        appState.clearSelection()
                        appState.addEntityToScene(for: .slide3, material: appState.selectedMaterialType)
                    }
                )
                .disabled(appState.phase != .buildingTrack)
                .accessibilityElement()
                .accessibilityLabel(Text("Add right turn piece."))
                
                ImageButton(
                    title: "Left Turn",
                    imageName: appState.leftTurnImageName,
                    buttonAction: { button in
                        appState.clearSelection()
                        appState.addEntityToScene(for: .slide4, material: appState.selectedMaterialType)
                    }
                )
                .disabled(appState.phase != .buildingTrack)
                .accessibilityElement()
                .accessibilityLabel(Text("Add left turn piece."))
            }
            GridRow {
                ImageButton(
                    title: "Slide",
                    imageName: appState.slideImageName,
                    buttonAction: { button in
                        appState.clearSelection()
                        appState.addEntityToScene(for: .slide2, material: appState.selectedMaterialType)
                    }
                )
                .disabled(appState.phase != .buildingTrack)
                .accessibilityElement()
                .accessibilityLabel(Text("Add straight slide piece."))
                
                ImageButton(
                    title: "Spiral",
                    imageName: appState.spiralImageName,
                    buttonAction: { button in
                        appState.clearSelection()
                        appState.addEntityToScene(for: .slide5, material: appState.selectedMaterialType)
                    }
                )
                .disabled(appState.phase != .buildingTrack)
                .accessibilityElement()
                .accessibilityLabel(Text("Add spiral slide piece."))
                ImageButton(
                    title: "Finish Line",
                    imageName: appState.goalImageNamne,
                    buttonAction: { button in
                        appState.addGoalPiece()
                        appState.hideMarkerPiece()
                        appState.clearSelection()
                        appState.updateConnections()
                    }
                )
                .disabled(endPieceIsInRealityView)
                .accessibilityElement()
                .accessibilityLabel(Text("Add finish line."))
                .onAppear {
                    Timer.scheduledTimer(withTimeInterval: 0.2, repeats: true) { _ in
                        endPieceIsInRealityView = appState.goalPiece?.parent != nil
                    }
                }
            }
        }
        .padding(.horizontal, 25)

    }
}

#Preview {
    PieceShelfTrackButtonsView()
        .environment(AppState())
}

----!@#$----
SwiftSplash/Views/TrackBuildingView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Displays the RealityKit content in an immersive space.
*/

import SwiftUI
import RealityKit
import SwiftSplashTrackPieces
import simd
/// The main immersive space for building the ride.
struct TrackBuildingView: View {
    @Environment(AppState.self) var appState
    @Environment(\.dismiss) internal var dismiss
    @Environment(\.openWindow) internal var openWindow
    
    @State internal var lastTouchDownTime: TimeInterval = 0
    
    @State internal var draggedEntity: Entity? = nil
    @State internal var rotatedEntity: Entity? = nil
    
    @State internal var shouldSingleTap = false
    @State internal var dragStartTime: TimeInterval?
    @State internal var subscriptions = [EventSubscription]()
    @State internal var rotationParent: Entity? = nil
    
    let doubleTapTolerance = 0.25
    static let editUIQuery = EntityQuery(where: .has(EditUILocationMarkerComponent.self))
    static let connectableQuery = EntityQuery(where: .has(ConnectableComponent.self))
    
    enum AttachmentIDs: Int {
        case editMenu = 100
        case startCard = 101
    }
    
    var body: some View {
        RealityView { content, attachments in
            content.add(appState.root)
            
            if let editMenu = attachments.entity(for: AttachmentIDs.editMenu) {
                appState.editAttachment = editMenu
                editMenu.components.set(BillboardComponent())
                
                if appState.trackPieceBeingEdited != nil {
                    appState.showEditAttachment()
                } else {
                    appState.hideEditAttachment()
                }
            }
            if let startMenu = attachments.entity(for: AttachmentIDs.startCard) {
                appState.startAttachment = startMenu
                if let startPiece = appState.startPiece {
                    startPiece.instructionsMarker?.addChild(startMenu)
                }
            }
        } attachments: {
            Attachment(id: AttachmentIDs.editMenu) {
                EditTrackPieceView()
            }
            Attachment(id: AttachmentIDs.startCard) {
                PlaceStartPieceView()
            }
        }
        .gesture(DragGesture(minimumDistance: 10)
            .targetedToAnyEntity()
            .onChanged { value in
                guard appState.phase == .buildingTrack || appState.phase == .placingStartPiece
                        || appState.phase == .draggingStartPiece else { return }
                handleDrag(value, ended: false)
            }
            .onEnded { value in
                guard appState.phase == .buildingTrack || appState.phase == .placingStartPiece
                        || appState.phase == .draggingStartPiece else { return }
                handleDrag(value, ended: true)
            })
        .simultaneousGesture(
            RotateGesture()
                .targetedToAnyEntity()
                .onChanged({ value in
                    guard appState.phase == .buildingTrack || appState.phase == .placingStartPiece
                            || appState.phase == .draggingStartPiece else { return }
                    handleRotationChanged(value)
                })
                .onEnded({ value in
                    guard appState.phase == .buildingTrack || appState.phase == .placingStartPiece
                            || appState.phase == .draggingStartPiece else { return }
                    handleRotationChanged(value, isEnded: true)
                })
        )
        .accessibilityAction(named: "Rotate selected pieces 90 degrees clockwise") {
            appState.rotateSelectedEntities(direction: .clockwise)
        }
        .accessibilityAction(named: "Rotate selected pieces 90 degrees counter-clockwise") {
            appState.rotateSelectedEntities(direction: .counterClockwise)
        }
        .simultaneousGesture(
            TapGesture(count: 2)
                .targetedToAnyEntity()
                .onEnded({ value in
                    guard appState.phase == .buildingTrack else { return }
                    shouldSingleTap = false
                    guard let entity = value.entity.connectableAncestor else {
                        logger.error("Double tap entity not found.")
                        return
                    }
                    if appState.trackPieceBeingEdited == nil {
                        appState.trackPieceBeingEdited = entity
                    } else {
                        appState.toggleTrackPieceInSelection(entity: entity)
                    }
                    appState.updateSelection()
                })
        )
        .simultaneousGesture(
            TapGesture()
                .targetedToAnyEntity()
                .onEnded({ value in
                    guard appState.phase == .buildingTrack else { return }
                    Task {
                        defer {
                            appState.updateVisuals()
                        }
                        
                        shouldSingleTap = true
                        try? await Task.sleep(for: .seconds(doubleTapTolerance))
                        if shouldSingleTap {
                            guard let entity = value.entity.connectableAncestor else {
                                logger.error("Tap gesture provided no entity.")
                                return
                            }
                            guard entity != appState.placePieceMarker else {
                                logger.info("Tap on placement marker. This piece doesn't support edit mode.")
                                return
                            }
                            
                            SoundEffect.selectPiece.play(on: entity)
                            
                            if appState.trackPieceBeingEdited == entity {
                                appState.trackPieceBeingEdited = nil
                                appState.clearSelection()
                                entity.connectableStateComponent?.isSelected = false
                                
                                appState.hideEditAttachment()
                                appState.updateConnections()
                                appState.updateSelection()
                            } else {
                                Task {
                                    appState.trackPieceBeingEdited = entity.connectableAncestor
                                    appState.trackPieceBeingEdited?.connectableStateComponent?.isSelected = true
                                    appState.clearSelection(keepPrimary: true)
                                    appState.showEditAttachment()
                                }
                            }
                            appState.updateConnections()
                            appState.updateSelection()
                        }
                        shouldSingleTap = false
                    }
                })
        )
        .onChange(of: appState.phase.isImmersed) { _, showMRView in
            if !showMRView {
                dismiss()
            }
        }
    }
}
    
#Preview {
    TrackBuildingView()
        .environment(AppState())
}

----!@#$----
SwiftSplash/Views/RideControlView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view for controlling the ride while it's running.
*/

import SwiftUI
import RealityKit

struct RideControlView: View {
    @Environment(AppState.self) var appState
    @State var elapsed: Double = 0.0
    @State private var animateIn = true
    @State private var canStartRide = false
    @State private var paused = true
    
    let timer = Timer.publish(every: 0.01, on: .main, in: .common).autoconnect()
    
    var body: some View {
        HStack {
            Toggle(isOn: $paused) {
                Label(shouldPauseRide ? "Play" : "Pause", systemImage: shouldPauseRide ? "play.fill" : "pause.fill")
                    .labelStyle(.iconOnly)
            }
            .toggleStyle(.button)
            .padding(.leading, 17)
            .accessibilityElement()
            .accessibilityLabel(shouldPauseRide ? Text("Play Ride") : Text("Pause Ride"))
            
            let elapsedTime = min(max(elapsed, 0), appState.rideDuration)
            ProgressView(value: elapsedTime, total: appState.rideDuration)
                .tint(.white)
                .onReceive(timer) { _ in
                    if pauseStartTime == 0 {
                        elapsed = (Date.timeIntervalSinceReferenceDate - appState.rideStartTime)
                    } else {
                        elapsed = (Date.timeIntervalSinceReferenceDate - appState.rideStartTime -
                                   (Date.timeIntervalSinceReferenceDate - pauseStartTime))
                    }
                }
                .accessibilityElement()
                .accessibilityValue(Text("\(String(format: "%2.0f", elapsed) + "percent complete.")"))
            
            Button {
                shouldCancelRide = true
                Task {
                    // Pause a moment to let the previous ride cancel.
                    try await Task.sleep(for: .seconds(0.1))
                    //SoundEffect.stopLoops()
                    appState.resetRideAnimations()
                    appState.goalPiece?.stopWaterfall()
                    appState.startRide()
                    appState.music = (shouldPauseRide) ? .silent : .ride
                    appState.addHoverEffectToConnectables()
                }
            } label: {
                Label("Restart Ride", systemImage: "arrow.counterclockwise")
                    .labelStyle(.iconOnly)
            }
            .buttonStyle(.borderless)
            .padding(.trailing, 9)
            .accessibilityElement()
            .accessibilityValue(Text("Start the ride over from the beginning."))
        }
        .opacity(animateIn ? 0.0 : 1.0)
        .onAppear {
            Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { _ in
                withAnimation(.easeInOut(duration: 0.7)) {
                    animateIn = false
                }
            }
            Timer.scheduledTimer(withTimeInterval: 0.2, repeats: true) { _ in
                canStartRide = appState.canStartRide
            }
        }
        .onDisappear {
            animateIn = true
        }
        .onChange(of: paused) {
            shouldPauseRide.toggle()
            
            if !shouldPauseRide {
                appState.rideStartTime += Date.timeIntervalSinceReferenceDate - pauseStartTime
                SoundEffect.enqueueEffectsForRide(appState, resume: true)
                appState.startPiece?.setRideLights(to: true, speed: 1.0)
                appState.goalPiece?.setRideLights(to: true, speed: 1.0)
            } else {
                SoundEffect.stopLoops()
                appState.startPiece?.setRideLights(to: true, speed: 0.0)
                appState.goalPiece?.setRideLights(to: true, speed: 0.0)
            }
            
            appState.music = shouldPauseRide ? .silent : .ride
        }
    }
}

#Preview {
    let appState = AppState()
    appState.startPiece = Entity()
    appState.goalPiece = Entity()
    return RideControlView().environment(appState)
}


----!@#$----
SwiftSplash/Views/TrackBuildingView+Snapping.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on the track-building view that contains functions related to snapping slide pieces together.
*/

import SwiftUI
import RealityKit
import SwiftSplashTrackPieces
import simd

struct DragSnapInfo: Sendable {
    var entity: Entity
    var otherSelectedEntities: [Entity]
}
extension TrackBuildingView {
    @MainActor

    func handleSnap(_ snapInfo: DragSnapInfo,
                    allConnectableEntities: QueryResult<Entity>) {
        let draggedEntity = snapInfo.entity
       
        guard let state = draggedEntity.connectableStateComponent else {
            logger.info("No entity recently dragged with state component.")
            return
        }
        
        // Calculate the time since the last move because snapping only happens for a short period of time after the player stops dragging.
        let timeSinceLastMove = Date.timeIntervalSinceReferenceDate - state.lastMoved
        
        // If no time has elapsed, then the piece is still being dragged and the app won't snap it.
        if timeSinceLastMove <= snapEpsilon {
            return
        }
        isSnapping = true
        // Snapping is based on the connection points of the end pieces only.
        var firstPiece: Entity? = draggedEntity
        var lastPiece: Entity?  = draggedEntity
        
        // Move backward to find the first dragged piece.
        while firstPiece?.connectableStateComponent?.previousPiece != nil {
            guard let previous = firstPiece?.connectableStateComponent?.previousPiece,
                  let previousState = previous.connectableStateComponent else { break }
            if previousState.isSelected {
                firstPiece = firstPiece?.connectableStateComponent?.previousPiece
            } else {
                break
            }
        }
        
        // Move forward to find last dragged piece.
        while lastPiece?.connectableStateComponent?.nextPiece != nil {
            guard let next = firstPiece?.connectableStateComponent?.nextPiece,
                  let nextState = next.connectableStateComponent else { break }
            if nextState.isSelected {
                lastPiece = lastPiece?.connectableStateComponent?.nextPiece
            } else {
                break
            }
        }
        
        var firstDistance = Float.greatestFiniteMagnitude
        var lastDistance = Float.greatestFiniteMagnitude
        var firstConnection: Entity? = nil
        var lastConnection: Entity? = nil
        
        if let firstPiece = firstPiece {
            let inConnectionFirst = appState.findNearestConnectionPoint(entity: firstPiece, connectionType: .inPoint)
            firstDistance = inConnectionFirst.distance
            firstConnection = inConnectionFirst.closestEntity
        }
        if let lastPiece = lastPiece {
            let outConnectionLast = appState.findNearestConnectionPoint(entity: lastPiece, connectionType: .outPoint)
            lastDistance = outConnectionLast.distance
            lastConnection = outConnectionLast.closestEntity
        }
        let distance = min(firstDistance, lastDistance)
        let snapTo = (firstDistance <= lastDistance) ? firstConnection : lastConnection
        let connectionType: ConnectionPointType = (firstDistance <= lastDistance) ? .inPoint : .outPoint
        
        // Nothing in snap distance, return.
        guard distance < maximumSnapDistance,
              let entity = (connectionType == .inPoint) ? firstPiece : lastPiece,
              let snapTo = snapTo,
              let ourSnapPoint = (connectionType == .inPoint) ? entity.inConnection?.scenePosition : entity.outConnection?.scenePosition,
              let otherSnapPoint = (connectionType == .inPoint) ? snapTo.outConnection?.scenePosition : snapTo.inConnection?.scenePosition,
              let ourConnectionVectorEntity = (connectionType == .inPoint) ? entity.inConnectionVector : entity.outConnectionVector,
              let otherConnectionVectorEntity = (connectionType == .inPoint) ? snapTo.outConnectionVector : snapTo.inConnectionVector else {
            logger.info("Returning because snap distance too large, or snap point or entity is nil")
            isSnapping = false
            isDragging = false
            isRotating = false
            return
        }
        
        let ourConnectionVector = ourConnectionVectorEntity.scenePosition - entity.scenePosition
        let otherConnectionVector = otherConnectionVectorEntity.scenePosition - snapTo.scenePosition
        
        // Check vectors to make sure the pieces are pointing in opposite directions.
        let dotProduct = simd_dot(simd_normalize(ourConnectionVector), simd_normalize(otherConnectionVector))
        
        if !((dotProduct > 0.95 && dotProduct < 1.05) ||
            (dotProduct < -0.95 && dotProduct > -1.05)) {
            isSnapping = false
            isDragging = false
            isRotating = false
            return
        }
        
        // If there's already comething connected to it, the piece doesn't snap.
        if (connectionType == .inPoint && snapTo.connectableStateComponent?.nextPiece != nil
            && snapTo.connectableStateComponent?.nextPiece != entity)
            || (connectionType == .outPoint && snapTo.connectableStateComponent?.previousPiece != nil
                && snapTo.connectableStateComponent?.previousPiece != entity) {
            logger.info("Track pieces don't snap if there's already a piece attached to the snap point. Returning.")
            isSnapping = false
            isDragging = false
            isRotating = false
            return
        }
        
        // Snap the pieces together.
        Task(priority: .userInitiated) {
            let lastMoved = Date.timeIntervalSinceReferenceDate
            let startTime = Date.timeIntervalSinceReferenceDate
            let deltaVector = otherSnapPoint - ourSnapPoint
            let dragStartPosition = draggedEntity.scenePosition
            let dragEndPosition = dragStartPosition + deltaVector
            
            var piecesToMove = [Entity]()
            if draggedEntity != appState.trackPieceBeingEdited && !appState.additionalSelectedTrackPieces.contains(draggedEntity) {
                appState.clearSelection()
            } else {
                guard let trackPieceBeingEdited = appState.trackPieceBeingEdited else {
                    isSnapping = true
                    return
                }
                piecesToMove.append(trackPieceBeingEdited)
                piecesToMove.append(contentsOf: appState.additionalSelectedTrackPieces)
            }
            var now = Date.timeIntervalSinceReferenceDate
            while now <= lastMoved + secondsAfterDragToContinueSnap {
                now = Date.timeIntervalSinceReferenceDate
                let totalElapsedTime = now - startTime
                
                let alpha = totalElapsedTime / secondsAfterDragToContinueSnap
                
                let newPosition = quarticLerp(dragStartPosition, dragEndPosition, Float(alpha))
                let otherDelta = newPosition - draggedEntity.scenePosition
                Task { @MainActor in
                    draggedEntity.scenePosition = newPosition
                }
                let others = piecesToMove.filter { $0 != draggedEntity }
                for other in others {
                    Task { @MainActor in
                        other.scenePosition += otherDelta
                    }
                }
                
                // Wait for one 90FPS frame.
                try? await Task.sleep(for: .milliseconds(11.111_11))
            }
            isSnapping = false
            isDragging = false
            isRotating = false
            appState.updateConnections()
            appState.updateVisuals()
        }
    }
}
/// This function performs a linear interpolation on a provided `Float` value based on a start, end, and progress value. It applies
/// a quartic  calculation to the result, which causes snapping to accelerate as it gets closer to the snap point. This gives a more
/// natural feel, much like a magnet accelerating toward the opposite pole of another magnet.
func quarticLerp(_ start: Float, _ end: Float, _ alpha: Float) -> Float {
    
    let alpha = min(max(alpha * alpha * alpha * alpha, 0), 1)
    
    return start * (1.0 - alpha) + end * alpha
}
/// This function performs a linear interpolation on a provided `SIMD3<Float>` value based on a start, end, and progress value. It applies
/// a quartic calculation to the result, which causes snapping to accelerate as it gets closer to the snap point. This gives a more
/// natural feel, much like a magnet accelerating toward the opposite pole of another magnet.
func quarticLerp(_ start: SIMD3<Float>, _ end: SIMD3<Float>, _ alpha: Float) -> SIMD3<Float> {
    let x = quarticLerp(start.x, end.x, alpha)
    let y = quarticLerp(start.y, end.y, alpha)
    let z = quarticLerp(start.z, end.z, alpha)
    return SIMD3<Float>(x: x, y: y, z: z)
}

----!@#$----
SwiftSplash/Views/PieceShelfView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The main SwiftUI view when building the ride.
*/

import CoreGraphics
import SwiftUI
import SwiftSplashTrackPieces
/// A UI element containing the various pieces the player can add to the track.
struct PieceShelfView: View {
    @Environment(AppState.self) var appState
    @Environment(\.dismiss) private var dismiss
    @State private var showStartOverConfirmation = false
    @State private var animateIn = true
    @State private var canStartRide = false
    
    let timer = Timer.publish(every: 0.01, on: .main, in: .common).autoconnect()
    
    static var displayedOnce = false

    var body: some View {
        @Bindable var appState = appState
        
        VStack {
            Picker("Material", selection: $appState.selectedMaterialIndex) {
                Text("Metal")
                    .tag(MaterialType.metal.rawValue)
                Text("Wood")
                    .tag(MaterialType.wood.rawValue)
                Text("Plastic")
                    .tag(MaterialType.plastic.rawValue)
            }
            .pickerStyle(.segmented)
            .padding(.horizontal, 25)
            .padding(.bottom)
            .accessibilityAction(named: Text("Select metallic material for next piece added.")) {
                appState.selectedMaterialType = .metal
            }
            .accessibilityAction(named: Text("Select wooden material for next piece added.")) {
                appState.selectedMaterialType = .wood
            }
            .accessibilityAction(named: Text("Select plastic material for next piece added.")) {
                appState.selectedMaterialType = .plastic
            }
            
            PieceShelfTrackButtonsView()
            
            Button {
                appState.startRide()
                appState.presentedRide = [.init()]
            } label: {
                Label("Start Ride", systemImage: "play.fill")
            }
            .disabled(!canStartRide)
            .controlSize(.large)
            .padding(.top)
            .onChange(of: appState.phase) { _, newPhase in
                if newPhase != .buildingTrack && newPhase != .rideRunning {
                    dismiss()
                }
            }
            .accessibilityElement()
        }
        .opacity(animateIn ? 0 : 1.0)
        .frame(width: 460, height: 420, alignment: .center)
        .onAppear {
            if Self.displayedOnce {
                Timer.scheduledTimer(withTimeInterval: 1.0, repeats: false) { _ in
                    withAnimation(.easeIn(duration: 0.7)) {
                        animateIn = false
                    }
                }
            } else {
                animateIn = false
            }
            
            Self.displayedOnce = true
            Timer.scheduledTimer(withTimeInterval: 0.2, repeats: true) { _ in
                canStartRide = appState.canStartRide
            }
        }
        .onDisappear {
            animateIn = true
        }
    }
}
struct TranslucentGroupBox: GroupBoxStyle {
    func makeBody(configuration: Configuration) -> some View {
        configuration.content
            .background(.regularMaterial)
    }
}
#Preview {
    PieceShelfView()
        .glassBackgroundEffect()
        .environment(AppState())
}

----!@#$----
SwiftSplash/Views/ImageButton.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view used by the app's buttons.
*/
import OSLog
import SwiftUI

/// A simple button with an image. This is used in the piece shelf.
public struct ImageButton: View {
    var title: String
    var imageName: String
    var imageBundle: Bundle? = nil
    var buttonAction: (ImageButton) -> Void
    // Use this to pass information to the button's action closure.
    var context = [String: Any]()
    
    @Environment(\.isEnabled) var isEnabled
    
    public var body: some View {
        Button {
            buttonAction(self)
        } label: {
            VStack {
                Image(imageName, bundle: imageBundle)
                    .resizable()
                    .scaledToFit()
                    .opacity(isEnabled ? 1.0 : 0.5)
                    
                Text(title)
                    .font(.system(size: 12))
                    .lineLimit(1)
                    .padding(.bottom, 10)
            }
        }
        .buttonStyle(.borderless)
        .buttonBorderShape(.roundedRectangle)
        .accessibilityElement()
    }
}
#Preview {
    ImageButton(title: "Simple Ramp", imageName: "slide_01_metal") { button in
        os_log("Pressed")
    }
    .glassBackgroundEffect(in: .rect(cornerRadius: 14))
    .frame(width: 86, height: 86)
}

----!@#$----
SwiftSplash/Views/PlaceStartPieceView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view that instructs the player to place the first piece of the ride.
*/

import SwiftUI
struct PlaceStartPieceView: View {
    @Environment(AppState.self) var appState
    let isAttachment: Bool
    
    init(asAttachment: Bool = true) {
        isAttachment = asAttachment
    }
    
    var body: some View {
        Text("Pinch and drag to place the first piece of the ride in your room.")
            .font(.system(size: 18))
            .fontWeight(.bold)
            .frame(width: 345)
            .lineLimit(2)
            .multilineTextAlignment(.center)
            
            .frame(maxWidth: 405, maxHeight: 100, alignment: .center)
            .glassBackgroundEffect()
            .onTapGesture {
                SoundEffect.fishGasp.play(on: appState.startPiece ?? appState.root)
            }
    }
}
#Preview {
    PlaceStartPieceView()
        .glassBackgroundEffect()
        .environment(AppState())
}

----!@#$----
SwiftSplash/Views/TrackBuildingView+Drag.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on the track-building view that contains functions related to dragging slide pieces.
*/

import SwiftUI
import RealityKit
import SwiftSplashTrackPieces
import simd

extension TrackBuildingView {
    
    /// The logic to handle the `.onChanged` event from a rotation gesture.
    @MainActor
    func handleDrag(_ value: EntityTargetValue<DragGesture.Value>, ended: Bool = false) {
        // On a rotate gesture, the drag gesture can sometimes also be called. Only one of the two
        // gestures should work at a time, so if there's a rotation in progress, return without
        // handling the drag.
        guard !isRotating else { return }
        
        defer {
            if ended {
                handleDragEnd(value)
                Task { @MainActor in
                    // Wait for snapping to finish.
                    try await Task.sleep(for: .seconds(0.25))
                    appState.showEditAttachment()
                }
                isDragging = false
            }
        }

        appState.hideEditAttachment()
    
        lastTouchDownTime = Date.timeIntervalSinceReferenceDate
        // Gestures might hit a child entity. This traverses up to the connectable ancestor, if needed.
        let tappedEntity = value.entity
        if let entity = tappedEntity.connectableAncestor {
            if appState.phase == .placingStartPiece {
                appState.startedDraggingStartPiece()
            }
            
            // Disallow dragging the end-of-track marker.
            if entity.name == SwiftSplashTrackPieces.placePieceMarkerName { return }
            draggedEntity = entity
            isDragging = true
            
            if appState.trackPieceBeingEdited != entity && !appState.additionalSelectedTrackPieces.contains(entity) {
                selectDraggedPiece(draggedEntity: draggedEntity)
            }
            
            if appState.trackPieceBeingEdited != nil && entity != appState.trackPieceBeingEdited
                && !appState.additionalSelectedTrackPieces.contains(entity) {
                appState.clearSelection(keepPrimary: false)
            }
            
            var allDragged = handleEntityStateUpdates(for: entity)
            
            draggedPiece = entity
            
            let translation3D = value.convert(value.gestureValue.translation3D, from: .local, to: .scene)
            
            let offset = SIMD3<Float>(x: Float(translation3D.x),
                                      y: Float(translation3D.y),
                                      z: Float(translation3D.z))
            
            updateDraggedPositions(&allDragged, offset: offset)
            
            // Handle snapping.
            if ended {
                let snapInfo = DragSnapInfo(entity: entity, otherSelectedEntities: Array(allDragged))
                guard let others = entity.scene?.performQuery(Self.connectableQuery) else {
                    logger.info("No entities to snap to, returning.")
                    isDragging = false
                    return
                }
                handleSnap(snapInfo,
                           allConnectableEntities: others)
                isDragging = false
            }
            if appState.phase != .draggingStartPiece {
                updateDraggedPieceConnections(entity: entity)
            }
        }
    }
    
    /// At the end of the drag, this function resets the dragged entities' state components.
    @MainActor
    func handleDragEnd(_ value: EntityTargetValue<DragGesture.Value>) {
        defer {
            isDragging = false
            draggedEntity = nil
            dragStartTime = nil
            appState.updateConnections()
            appState.updateSelection()
        }
        
        if appState.phase == .draggingStartPiece {
            openWindow(id: "SwiftSplash")
            appState.finishedDraggingStartPiece()
        }
        
        func resetPiece(_ entity: Entity) {
            if var state = entity.connectableStateComponent {
                state.nextPiece = nil
                state.previousPiece = nil
                state.lastMoved = NSDate.timeIntervalSinceReferenceDate
                state.dragOffset = SIMD3<Float>.zero
                state.dragStart = nil
                entity.connectableStateComponent = state
                appState.findClosestPieces(for: entity)
                SoundEffect.placePiece.play(on: entity)
                if entity == appState.trackPieceBeingEdited {
                    appState.showEditAttachment()
                }
            }
        }
        if let dragged = appState.trackPieceBeingEdited {
            resetPiece(dragged)
        }
        for dragged in appState.additionalSelectedTrackPieces {
            resetPiece(dragged)
        }
        
        appState.showEditAttachment()

    }
    
    /// Updates a dragged entity's state component based on the results of the drag.
    @MainActor
    private func handleEntityStateUpdates(for entity: Entity) -> Set<Entity> {
        defer {
            isDragging = false
        }
        var allDragged = Set<Entity>(appState.additionalSelectedTrackPieces)
        allDragged.insert(entity)
        if entity != appState.trackPieceBeingEdited,
            let selected = appState.trackPieceBeingEdited {
            allDragged.insert(selected)
        }
        guard var state = entity.connectableStateComponent else { return Set<Entity>() }
        if state.dragStart == nil {
            state.lastMoved = NSDate.timeIntervalSinceReferenceDate
            state.dragStart = entity.scenePosition
            SoundEffect.selectPiece.play(on: entity)
            
            for piece in allDragged {
                piece.connectableStateComponent?.dragStart = piece.scenePosition
                piece.connectableStateComponent?.dragOffset = .zero
            }
            entity.connectableStateComponent = state
        }

        return allDragged
    }
    
    /// As slide pieces are dragged, their connection status to other pieces changes. This
    /// determines if the piece, in its current location, is connected to another piece,
    /// and updates the pieces state component if it is.
    @MainActor
    private func updateDraggedPieceConnections(entity: Entity) {
        appState.findClosestPieces(for: entity)
        if let next = entity.connectableStateComponent?.nextPiece {
            appState.findClosestPieces(for: next)
        }
        if let previous = entity.connectableStateComponent?.previousPiece {
            appState.findClosestPieces(for: previous    )
        }
    }
    
    @MainActor
    private func selectDraggedPiece(draggedEntity: Entity?) {
        appState.clearSelection()
        appState.trackPieceBeingEdited = draggedEntity
        draggedEntity?.connectableStateComponent?.isSelected = true
        appState.updateConnections()
        appState.updateSelection()
    }
    
    /// If multiple pieces are dragged at once, this function applies the drag offset to all of them.
    @MainActor
    private func updateDraggedPositions(_ allDragged: inout Set<Entity>, offset: SIMD3<Float>) {
        for oneDragged in allDragged {
            oneDragged.connectableStateComponent?.dragOffset = offset
            guard let oneState = oneDragged.connectableStateComponent,
                  let dragStart = oneState.dragStart else {
                continue
            }
            if oneDragged.parent?.name != rotatingParentNodeName {
                oneDragged.scenePosition = dragStart + oneState.dragOffset
            }
        }
        appState.updateMarkerPosition()
    }
}

----!@#$----
SwiftSplash/Views/EditTrackPieceView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A SwiftUI view used as an attachment to edit the selected piece or pieces.
*/
import SwiftSplashTrackPieces
import SwiftUI
struct EditTrackPieceView: View {
    @Environment(AppState.self) var appState
    @State private var isSelecting = true
    @Environment(\.dismiss) private var dismiss
    
    var body: some View {
        VStack {
            HStack(spacing: 0) {
                Button {
                    appState.selectConnectedPieces()
                } label: {
                    Label("Select Attached", systemImage: "plus.square.dashed")
                    .fontWeight(.semibold)
                    .frame(width: 180)
                }
                .padding(.leading, 20)
                .accessibilityElement()
                .accessibilityLabel(Text("Select all ride pieces that connect back to this piece."))
                
                Spacer()
                
                Button(role: .destructive) {
                    if let goalPiece = appState.goalPiece {
                        if appState.trackPieceBeingEdited == goalPiece ||
                            appState.additionalSelectedTrackPieces.contains(goalPiece) {
                            goalPiece.removeFromParent()
                        }
                    }
                    appState.deleteSelectedPieces()
                    
                } label: {
                    Label("Delete", systemImage: "trash")
                        .labelStyle(.iconOnly)
                }
                .disabled(appState.trackPieceBeingEdited == appState.startPiece)
                .accessibilityElement()
                .accessibilityLabel(Text("Delete all selected ride pieces."))
                
                Button {
                    appState.clearSelection(keepPrimary: false)
                } label: {
                    Label("Dismiss", systemImage: "checkmark")
                        .labelStyle(.iconOnly)
                }
                .padding(.trailing, 5)
                .accessibilityElement()
                .accessibilityLabel(Text("Clear the selection and dismiss this window."))
            }
            .padding(.vertical)
            .frame(width: 350)
            .background(.regularMaterial)
            
            HStack {
                Button {
                    appState.setMaterialForAllSelected(.metal)
                } label: {
                    VStack {
                        Image(decorative: "metalPreview")
                            .resizable()
                            .frame(width: 50, height: 50)
                        Text("Metal")
                    }
                    .padding(.vertical, 10)
                }
                .accessibilityElement()
                .accessibilityLabel(Text("Change all selected pieces to use a metal material."))
                
                Button {
                    appState.setMaterialForAllSelected(.wood)
                } label: {
                    VStack {
                        Image(decorative: "woodPreview")
                            .resizable()
                            .frame(width: 50, height: 50)
                        Text("Wood")
                    }
                    .padding(.vertical, 10)
                }
                .accessibilityElement()
                .accessibilityLabel(Text("Change all selected pieces to use a wood material."))
                
                Button {
                    appState.setMaterialForAllSelected(.plastic)
                } label: {
                    VStack {
                        Image(decorative: "plasticPreview")
                            .resizable()
                            .frame(width: 50, height: 50)
                        Text("Plastic")
                    }
                    .padding(.vertical, 10)
                }
                .accessibilityElement()
                .accessibilityLabel(Text("Change all selected pieces to use a plastic material."))
            }
            .buttonBorderShape(.roundedRectangle(radius: 15))
            .buttonStyle(.borderless)
            .padding()
        }
        .glassBackgroundEffect()
    }
}
#Preview {
    VStack {
        Spacer()
        EditTrackPieceView()
            .environment(AppState())
    }
}

----!@#$----
SwiftSplash/Views/ContentView.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
The app's main SwiftUI view.
*/

import SwiftUI
import RealityKit
/// The app's main view.
struct ContentView: View {
    @Environment(AppState.self) private var appState
    @Environment(\.dismissImmersiveSpace) private var dismissImmersiveSpace
    @Environment(\.scenePhase) private var scenePhase
    
    private let lightGrayTextColor = Color(white: 0.84)
    @State private var countDown: CFAbsoluteTime = -1.0
    @State private var confirmationShown = false
    @State private var isReducedHeight = false
    
    var body: some View {
        @Bindable var appState = appState
        switch appState.phase {
            case .startingUp, .waitingToStart, .loadingAssets, .placingStartPiece, .draggingStartPiece:
                Spacer()
                SplashScreenView()
                    .onAppear {
                        guard let windowScene = UIApplication.shared.connectedScenes.first as? UIWindowScene else {
                            return
                        }
                        
                        windowScene.requestGeometryUpdate(.Vision(resizingRestrictions: UIWindowScene.ResizingRestrictions.none))
                    }
                    .glassBackgroundEffect()
            case .buildingTrack, .rideRunning:
                Spacer()
                NavigationStack(path: $appState.presentedRide) {
                    PieceShelfView()
                        .transition(.opacity)
                        .navigationTitle("Build")
                        .navigationBarTitleDisplayMode(.inline)
                        .navigationDestination(for: RideDestination.self) { ride in
                            RideControlView()
                                .transition(.opacity)
                                .navigationTitle("Ride")
                                .navigationBarTitleDisplayMode(.inline)
                                .toolbar {
                                    Button {
                                        appState.isVolumeMuted.toggle()
                                    } label: {
                                        Label {
                                            if appState.isVolumeMuted {
                                                Text("Unmute")
                                            } else {
                                                Text("Mute")
                                            }
                                        } icon: {
                                            if appState.isVolumeMuted {
                                                Image(systemName: "speaker.slash.fill")
                                            } else {
                                                Image(systemName: "speaker.wave.3.fill")
                                            }
                                        }
                                        .animation(.none, value: 0)
                                        .fontWeight(.semibold)
                                        .frame(width: 100)
                                    }
                                }
                                .toolbar(.visible, for: .navigationBar)
                                .toolbarRole(.navigationStack)
                        }
                        .toolbar {
                            Button(role: .destructive) {
                                confirmationShown = true
                            } label: {
                                Label("Delete ride", systemImage: "trash.fill")
                            }
                            .accessibilityElement()
                            .confirmationDialog(
                                "Are you sure you want to delete all pieces and start over?",
                                isPresented: $confirmationShown,
                                titleVisibility: .visible
                            ) {
                                Text("Are you sure you want to delete all pieces and start over?")
                                Button("Delete ride", role: .destructive) {
                                    withAnimation {
                                        appState.resetBoard()
                                    }
                                }
                                Button("Continue editing", role: .cancel) {
                                }
                            }
                            
                            Button {
                                if appState.trackPieceBeingEdited == nil {
                                    appState.trackPieceBeingEdited = appState.startPiece
                                    appState.trackPieceBeingEdited?.connectableStateComponent?.isSelected = true
                                    appState.showEditAttachment()
                                }
                                
                                appState.updateConnections()
                                appState.updateSelection()
                                appState.selectAll()
                            } label: {
                                Label("Select All", systemImage: "plus.square.dashed")
                            }
                            .accessibilityElement()
                            
                            Button {
                                appState.isVolumeMuted.toggle()
                            } label: {
                                Label {
                                    if appState.isVolumeMuted {
                                        Text("Unmute")
                                    } else {
                                        Text("Mute")
                                    }
                                } icon: {
                                    if appState.isVolumeMuted {
                                        Image(systemName: "speaker.slash.fill")
                                    } else {
                                        Image(systemName: "speaker.wave.3.fill")
                                    }
                                }
                                .animation(.none, value: 0)
                                .fontWeight(.semibold)
                                .frame(width: 100)
                            }
                            .accessibilityElement()
                        }
                        .toolbar(.visible, for: .navigationBar)
                        .onChange(of: appState.trackPieceBeingEdited) { _, trackPieceBeingEdited in
                            guard let trackPieceBeingEdited = trackPieceBeingEdited else { return }
                            trackPieceBeingEdited.connectableStateComponent?.isSelected = true
                            appState.updateSelection()
                        }
                }
                .frame(width: 460, height: !isReducedHeight ? 540 : 200)
                
                // If someone closes the main window, dismiss the immersive space. If placing the first piece, ignore it.
                .onChange(of: scenePhase) { _, newPhase in
                    Task {
                        if (newPhase == .background || newPhase == .inactive) && appState.isImmersiveViewShown
                            && appState.phase != .placingStartPiece && appState.phase != .draggingStartPiece {
                            appState.resetBoard()
                            appState.goBackToWaiting()
                            await dismissImmersiveSpace()
                            appState.isImmersiveViewShown = false
                        }
                    }
                }
                .onChange(of: appState.presentedRide) {
                    if appState.presentedRide.isEmpty {
                        withAnimation {
                            // Went back.
                            shouldCancelRide = true
                            appState.resetRideAnimations()
                            appState.addHoverEffectToConnectables()
                            appState.goalPiece?.stopWaterfall()
                            appState.returnToBuildingTrack()
                            appState.isRideRunning = false
                            appState.music = .build
                            SoundEffect.stopLoops()
                            appState.updateConnections()
                            appState.updateSelection()
                            appState.goalPiece?.setAllParticleEmittersTo(to: false)
                        }
                    } else {
                        // Play.
                        shouldCancelRide = false
                    }
                    
                    Timer.scheduledTimer(withTimeInterval: 0.1, repeats: false) { _ in
                        Task {
                            withAnimation(.easeIn(duration: 1.0)) {
                                if appState.presentedRide.isEmpty {
                                    isReducedHeight = false
                                } else {
                                    isReducedHeight = true
                                }
                            }
                        }
                    }
                }
        }
    }
}

#Preview {
    ContentView()
        .environment(AppState())
}

----!@#$----
Configuration/SampleCode.xcconfig
//
// See the LICENSE.txt file for this sample’s licensing information.
//
// SampleCode.xcconfig
//

// The `SAMPLE_CODE_DISAMBIGUATOR` configuration is to make it easier to build
// and run a sample code project. Once you set your project's development team,
// you'll have a unique bundle identifier. This is because the bundle identifier
// is derived based on the 'SAMPLE_CODE_DISAMBIGUATOR' value. Do not use this
// approach in your own projects—it's only useful for sample code projects because
// they are frequently downloaded and don't have a development team set.
SAMPLE_CODE_DISAMBIGUATOR=${DEVELOPMENT_TEAM}

----!@#$----
SwiftSplash.xcodeproj/project.pbxproj
// !$*UTF8*$!
{
	archiveVersion = 1;
	classes = {
	};
	objectVersion = 56;
	objects = {

/* Begin PBXBuildFile section */
		1F13D56E2984620500EC78A8 /* SwiftSplashTrackPieces in Frameworks */ = {isa = PBXBuildFile; productRef = 1F13D56D2984620500EC78A8 /* SwiftSplashTrackPieces */; };
		1F2FE882291DA7CD008D6795 /* AppState.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F2FE881291DA7CD008D6795 /* AppState.swift */; };
		1F30FEED2AA12644006352A2 /* AppState+PieceLoading.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F30FEEC2AA12644006352A2 /* AppState+PieceLoading.swift */; };
		1F30FF692AA140E6006352A2 /* PieceShelfTrackButtonsView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F30FF682AA140E6006352A2 /* PieceShelfTrackButtonsView.swift */; };
		1F46FABE2922E9C100B38A70 /* TrackBuildingView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F46FABD2922E9C100B38A70 /* TrackBuildingView.swift */; };
		1F46FAC0292408F600B38A70 /* PieceShelfView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F46FABF292408F600B38A70 /* PieceShelfView.swift */; };
		1F52B60F2A97C49F00C93EB9 /* AppConfig.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F52B60E2A97C49F00C93EB9 /* AppConfig.swift */; };
		1F52B6112A9917B600C93EB9 /* AppState+RideRunning.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F52B6102A9917B600C93EB9 /* AppState+RideRunning.swift */; };
		1F54B77A29773E4100D5E2B2 /* AppState+Phases.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F54B77929773E4100D5E2B2 /* AppState+Phases.swift */; };
		1F59CE01298854C8008566FF /* AppState+PieceManagement.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F59CE00298854C8008566FF /* AppState+PieceManagement.swift */; };
		1F59CE052989B248008566FF /* AppPhase.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F59CE042989B248008566FF /* AppPhase.swift */; };
		1F5ED3072A81B04C00843A5A /* TrackBuildingView+Snapping.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F5ED3062A81B04C00843A5A /* TrackBuildingView+Snapping.swift */; };
		1F5ED3092A82B75100843A5A /* AppState+TrackUpdates.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F5ED3082A82B75100843A5A /* AppState+TrackUpdates.swift */; };
		1F6BF61B2919C4D8006F6A58 /* SwiftSplashApp.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F6BF61A2919C4D8006F6A58 /* SwiftSplashApp.swift */; };
		1F6BF61F2919C4D8006F6A58 /* ContentView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F6BF61E2919C4D8006F6A58 /* ContentView.swift */; };
		1F6BF6212919C4D9006F6A58 /* Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 1F6BF6202919C4D9006F6A58 /* Assets.xcassets */; };
		1F6BF6242919C4D9006F6A58 /* Preview Assets.xcassets in Resources */ = {isa = PBXBuildFile; fileRef = 1F6BF6232919C4D9006F6A58 /* Preview Assets.xcassets */; };
		1F7D201D2926899100FC115F /* ImageButton.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F7D201C2926899100FC115F /* ImageButton.swift */; };
		1F8922C32926C9A2005E1B39 /* Piece.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1F8922C22926C9A2005E1B39 /* Piece.swift */; };
		1FB4DEF6294014B900F8CABB /* SplashScreenView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FB4DEF5294014B900F8CABB /* SplashScreenView.swift */; };
		1FC75A702AA115AE005B6A87 /* Date+Logging.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FC75A6F2AA115AE005B6A87 /* Date+Logging.swift */; };
		1FC75A722AA1167A005B6A87 /* TrackBuildingView+Drag.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FC75A712AA1167A005B6A87 /* TrackBuildingView+Drag.swift */; };
		1FC75A742AA1172F005B6A87 /* TrackBuildingView+Rotation.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FC75A732AA1172F005B6A87 /* TrackBuildingView+Rotation.swift */; };
		1FC75A762AA1183A005B6A87 /* AppState+PieceSelection.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FC75A752AA1183A005B6A87 /* AppState+PieceSelection.swift */; };
		1FDA9A092993F98000CD1951 /* EditTrackPieceView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FDA9A082993F98000CD1951 /* EditTrackPieceView.swift */; };
		1FEB134C2ABD0A68007C36F7 /* Entity+SwiftSplash.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FEB134B2ABD0A68007C36F7 /* Entity+SwiftSplash.swift */; };
		1FEFF2DB2AA10C66002B43C7 /* AppState+Transparency.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FEFF2DA2AA10C66002B43C7 /* AppState+Transparency.swift */; };
		1FFF8F95293FEDE1000B15BB /* PlaceStartPieceView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 1FFF8F94293FEDE1000B15BB /* PlaceStartPieceView.swift */; };
		32AF04F82A8BDC270080BDCD /* SoundEffects.swift in Sources */ = {isa = PBXBuildFile; fileRef = 32AF04F72A8BDC270080BDCD /* SoundEffects.swift */; };
		32AF05062A8BE0C70080BDCD /* swiftSplash_RideMode.m4a in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04F92A8BE0C50080BDCD /* swiftSplash_RideMode.m4a */; };
		32AF05072A8BE0C70080BDCD /* fishSound_longLoudHappy.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04FA2A8BE0C50080BDCD /* fishSound_longLoudHappy.wav */; };
		32AF05082A8BE0C70080BDCD /* deletePiece.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04FB2A8BE0C50080BDCD /* deletePiece.wav */; };
		32AF050A2A8BE0C70080BDCD /* swiftSplash_Menu.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04FD2A8BE0C60080BDCD /* swiftSplash_Menu.wav */; };
		32AF050B2A8BE0C70080BDCD /* fishSound_mediumHappy.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04FE2A8BE0C60080BDCD /* fishSound_mediumHappy.wav */; };
		32AF050C2A8BE0C70080BDCD /* fishSound_quietHappy.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF04FF2A8BE0C60080BDCD /* fishSound_quietHappy.wav */; };
		32AF050D2A8BE0C70080BDCD /* waterFlowing.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF05002A8BE0C60080BDCD /* waterFlowing.wav */; };
		32AF050E2A8BE0C70080BDCD /* pickUp.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF05012A8BE0C60080BDCD /* pickUp.wav */; };
		32AF050F2A8BE0C70080BDCD /* swiftSplash_BuildMode.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF05022A8BE0C70080BDCD /* swiftSplash_BuildMode.wav */; };
		32AF05122A8BE0C70080BDCD /* placePiece.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AF05052A8BE0C70080BDCD /* placePiece.wav */; };
		32AFFAD42AB0FC5C0093488C /* startRide.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AFFAD32AB0FC5C0093488C /* startRide.wav */; };
		32AFFAD62AB0FC6E0093488C /* endRide.wav in Resources */ = {isa = PBXBuildFile; fileRef = 32AFFAD52AB0FC6E0093488C /* endRide.wav */; };
		8DA28C5A29D5010B00132CFC /* RideControlView.swift in Sources */ = {isa = PBXBuildFile; fileRef = 8DA28C5929D5010B00132CFC /* RideControlView.swift */; };
/* End PBXBuildFile section */

/* Begin PBXFileReference section */
		069DF3ADB744789956636AF1 /* SampleCode.xcconfig */ = {isa = PBXFileReference; name = SampleCode.xcconfig; path = Configuration/SampleCode.xcconfig; sourceTree = "<group>"; };
		1F2FE881291DA7CD008D6795 /* AppState.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppState.swift; sourceTree = "<group>"; };
		1F30FEEC2AA12644006352A2 /* AppState+PieceLoading.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+PieceLoading.swift"; sourceTree = "<group>"; };
		1F30FF682AA140E6006352A2 /* PieceShelfTrackButtonsView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PieceShelfTrackButtonsView.swift; sourceTree = "<group>"; };
		1F46FABD2922E9C100B38A70 /* TrackBuildingView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = TrackBuildingView.swift; sourceTree = "<group>"; };
		1F46FABF292408F600B38A70 /* PieceShelfView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PieceShelfView.swift; sourceTree = "<group>"; };
		1F52B60E2A97C49F00C93EB9 /* AppConfig.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppConfig.swift; sourceTree = "<group>"; };
		1F52B6102A9917B600C93EB9 /* AppState+RideRunning.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+RideRunning.swift"; sourceTree = "<group>"; };
		1F54B77929773E4100D5E2B2 /* AppState+Phases.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+Phases.swift"; sourceTree = "<group>"; };
		1F59CE00298854C8008566FF /* AppState+PieceManagement.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+PieceManagement.swift"; sourceTree = "<group>"; };
		1F59CE042989B248008566FF /* AppPhase.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = AppPhase.swift; sourceTree = "<group>"; };
		1F5ED3062A81B04C00843A5A /* TrackBuildingView+Snapping.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "TrackBuildingView+Snapping.swift"; sourceTree = "<group>"; };
		1F5ED3082A82B75100843A5A /* AppState+TrackUpdates.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+TrackUpdates.swift"; sourceTree = "<group>"; };
		1F6BF6132919C4D8006F6A58 /* SwiftSplash.app */ = {isa = PBXFileReference; explicitFileType = wrapper.application; includeInIndex = 0; path = SwiftSplash.app; sourceTree = BUILT_PRODUCTS_DIR; };
		1F6BF61A2919C4D8006F6A58 /* SwiftSplashApp.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SwiftSplashApp.swift; sourceTree = "<group>"; };
		1F6BF61E2919C4D8006F6A58 /* ContentView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ContentView.swift; sourceTree = "<group>"; };
		1F6BF6202919C4D9006F6A58 /* Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = Assets.xcassets; sourceTree = "<group>"; };
		1F6BF6232919C4D9006F6A58 /* Preview Assets.xcassets */ = {isa = PBXFileReference; lastKnownFileType = folder.assetcatalog; path = "Preview Assets.xcassets"; sourceTree = "<group>"; };
		1F7D201C2926899100FC115F /* ImageButton.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = ImageButton.swift; sourceTree = "<group>"; };
		1F8922C22926C9A2005E1B39 /* Piece.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = Piece.swift; sourceTree = "<group>"; };
		1FB4DEF5294014B900F8CABB /* SplashScreenView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SplashScreenView.swift; sourceTree = "<group>"; };
		1FBED399297B5E7F00B5B8CB /* SwiftSplashTrackPieces */ = {isa = PBXFileReference; lastKnownFileType = wrapper; path = SwiftSplashTrackPieces; sourceTree = "<group>"; };
		1FC75A6F2AA115AE005B6A87 /* Date+Logging.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Date+Logging.swift"; sourceTree = "<group>"; };
		1FC75A712AA1167A005B6A87 /* TrackBuildingView+Drag.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "TrackBuildingView+Drag.swift"; sourceTree = "<group>"; };
		1FC75A732AA1172F005B6A87 /* TrackBuildingView+Rotation.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "TrackBuildingView+Rotation.swift"; sourceTree = "<group>"; };
		1FC75A752AA1183A005B6A87 /* AppState+PieceSelection.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+PieceSelection.swift"; sourceTree = "<group>"; };
		1FDA9A082993F98000CD1951 /* EditTrackPieceView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = EditTrackPieceView.swift; sourceTree = "<group>"; };
		1FEB134B2ABD0A68007C36F7 /* Entity+SwiftSplash.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "Entity+SwiftSplash.swift"; sourceTree = "<group>"; };
		1FEFF2DA2AA10C66002B43C7 /* AppState+Transparency.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = "AppState+Transparency.swift"; sourceTree = "<group>"; };
		1FFF8F94293FEDE1000B15BB /* PlaceStartPieceView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = PlaceStartPieceView.swift; sourceTree = "<group>"; };
		2D505F93475BBFCEC47570B3 /* LICENSE.txt */ = {isa = PBXFileReference; includeInIndex = 1; path = LICENSE.txt; sourceTree = "<group>"; };
		32AF04F72A8BDC270080BDCD /* SoundEffects.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = SoundEffects.swift; sourceTree = "<group>"; };
		32AF04F92A8BE0C50080BDCD /* swiftSplash_RideMode.m4a */ = {isa = PBXFileReference; lastKnownFileType = file; path = swiftSplash_RideMode.m4a; sourceTree = "<group>"; };
		32AF04FA2A8BE0C50080BDCD /* fishSound_longLoudHappy.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = fishSound_longLoudHappy.wav; sourceTree = "<group>"; };
		32AF04FB2A8BE0C50080BDCD /* deletePiece.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = deletePiece.wav; sourceTree = "<group>"; };
		32AF04FD2A8BE0C60080BDCD /* swiftSplash_Menu.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = swiftSplash_Menu.wav; sourceTree = "<group>"; };
		32AF04FE2A8BE0C60080BDCD /* fishSound_mediumHappy.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = fishSound_mediumHappy.wav; sourceTree = "<group>"; };
		32AF04FF2A8BE0C60080BDCD /* fishSound_quietHappy.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = fishSound_quietHappy.wav; sourceTree = "<group>"; };
		32AF05002A8BE0C60080BDCD /* waterFlowing.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = waterFlowing.wav; sourceTree = "<group>"; };
		32AF05012A8BE0C60080BDCD /* pickUp.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = pickUp.wav; sourceTree = "<group>"; };
		32AF05022A8BE0C70080BDCD /* swiftSplash_BuildMode.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = swiftSplash_BuildMode.wav; sourceTree = "<group>"; };
		32AF05052A8BE0C70080BDCD /* placePiece.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = placePiece.wav; sourceTree = "<group>"; };
		32AFFAD32AB0FC5C0093488C /* startRide.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = startRide.wav; sourceTree = "<group>"; };
		32AFFAD52AB0FC6E0093488C /* endRide.wav */ = {isa = PBXFileReference; lastKnownFileType = audio.wav; path = endRide.wav; sourceTree = "<group>"; };
		7BD16BDA1984B90A7596FE8F /* README.md */ = {isa = PBXFileReference; lastKnownFileType = net.daringfireball.markdown; path = README.md; sourceTree = "<group>"; };
		8DA28C5929D5010B00132CFC /* RideControlView.swift */ = {isa = PBXFileReference; lastKnownFileType = sourcecode.swift; path = RideControlView.swift; sourceTree = "<group>"; };
/* End PBXFileReference section */

/* Begin PBXFrameworksBuildPhase section */
		1F6BF6102919C4D8006F6A58 /* Frameworks */ = {
			isa = PBXFrameworksBuildPhase;
			buildActionMask = 2147483647;
			files = (
				1F13D56E2984620500EC78A8 /* SwiftSplashTrackPieces in Frameworks */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXFrameworksBuildPhase section */

/* Begin PBXGroup section */
		15BE7B7884206C264A0BCAFA /* LICENSE */ = {
			isa = PBXGroup;
			children = (
				2D505F93475BBFCEC47570B3 /* LICENSE.txt */,
			);
			name = LICENSE;
			path = LICENSE;
			sourceTree = "<group>";
		};
		1F2331EE2925425A00D5EAFC /* Views */ = {
			isa = PBXGroup;
			children = (
				1F6BF61E2919C4D8006F6A58 /* ContentView.swift */,
				1FDA9A082993F98000CD1951 /* EditTrackPieceView.swift */,
				1F7D201C2926899100FC115F /* ImageButton.swift */,
				1F46FABF292408F600B38A70 /* PieceShelfView.swift */,
				1F30FF682AA140E6006352A2 /* PieceShelfTrackButtonsView.swift */,
				1FFF8F94293FEDE1000B15BB /* PlaceStartPieceView.swift */,
				8DA28C5929D5010B00132CFC /* RideControlView.swift */,
				1FB4DEF5294014B900F8CABB /* SplashScreenView.swift */,
				1F46FABD2922E9C100B38A70 /* TrackBuildingView.swift */,
				1FC75A712AA1167A005B6A87 /* TrackBuildingView+Drag.swift */,
				1FC75A732AA1172F005B6A87 /* TrackBuildingView+Rotation.swift */,
				1F5ED3062A81B04C00843A5A /* TrackBuildingView+Snapping.swift */,
			);
			path = Views;
			sourceTree = "<group>";
		};
		1F6BF60A2919C4D8006F6A58 = {
			isa = PBXGroup;
			children = (
				7BD16BDA1984B90A7596FE8F /* README.md */,
				1F6BF6152919C4D8006F6A58 /* SwiftSplash */,
				1F6BF6162919C4D8006F6A58 /* Packages */,
				1F6BF6142919C4D8006F6A58 /* Products */,
				1FBED39A297B5E8B00B5B8CB /* Frameworks */,
				6F638E4B1FF9394F7F4DE68D /* Configuration */,
				15BE7B7884206C264A0BCAFA /* LICENSE */,
			);
			sourceTree = "<group>";
		};
		1F6BF6142919C4D8006F6A58 /* Products */ = {
			isa = PBXGroup;
			children = (
				1F6BF6132919C4D8006F6A58 /* SwiftSplash.app */,
			);
			name = Products;
			sourceTree = "<group>";
		};
		1F6BF6152919C4D8006F6A58 /* SwiftSplash */ = {
			isa = PBXGroup;
			children = (
				1F6BF61A2919C4D8006F6A58 /* SwiftSplashApp.swift */,
				1F8922C12926C98D005E1B39 /* Data & State */,
				1F2331EE2925425A00D5EAFC /* Views */,
				1FC75A6E2AA11594005B6A87 /* Extensions */,
				1FD4BBD829AE9CAF00B52FBC /* Assets */,
				1F6BF6202919C4D9006F6A58 /* Assets.xcassets */,
				1F6BF6222919C4D9006F6A58 /* Preview Content */,
			);
			path = SwiftSplash;
			sourceTree = "<group>";
		};
		1F6BF6162919C4D8006F6A58 /* Packages */ = {
			isa = PBXGroup;
			children = (
				1FBED399297B5E7F00B5B8CB /* SwiftSplashTrackPieces */,
			);
			path = Packages;
			sourceTree = "<group>";
		};
		1F6BF6222919C4D9006F6A58 /* Preview Content */ = {
			isa = PBXGroup;
			children = (
				1F6BF6232919C4D9006F6A58 /* Preview Assets.xcassets */,
			);
			path = "Preview Content";
			sourceTree = "<group>";
		};
		1F8922C12926C98D005E1B39 /* Data & State */ = {
			isa = PBXGroup;
			children = (
				1F52B60E2A97C49F00C93EB9 /* AppConfig.swift */,
				1F59CE042989B248008566FF /* AppPhase.swift */,
				1F2FE881291DA7CD008D6795 /* AppState.swift */,
				1F54B77929773E4100D5E2B2 /* AppState+Phases.swift */,
				1F30FEEC2AA12644006352A2 /* AppState+PieceLoading.swift */,
				1F59CE00298854C8008566FF /* AppState+PieceManagement.swift */,
				1FC75A752AA1183A005B6A87 /* AppState+PieceSelection.swift */,
				1F52B6102A9917B600C93EB9 /* AppState+RideRunning.swift */,
				1F5ED3082A82B75100843A5A /* AppState+TrackUpdates.swift */,
				1FEFF2DA2AA10C66002B43C7 /* AppState+Transparency.swift */,
				1F8922C22926C9A2005E1B39 /* Piece.swift */,
				32AF04F72A8BDC270080BDCD /* SoundEffects.swift */,
			);
			path = "Data & State";
			sourceTree = "<group>";
		};
		1FBED39A297B5E8B00B5B8CB /* Frameworks */ = {
			isa = PBXGroup;
			children = (
			);
			name = Frameworks;
			sourceTree = "<group>";
		};
		1FC75A6E2AA11594005B6A87 /* Extensions */ = {
			isa = PBXGroup;
			children = (
				1FC75A6F2AA115AE005B6A87 /* Date+Logging.swift */,
				1FEB134B2ABD0A68007C36F7 /* Entity+SwiftSplash.swift */,
			);
			path = Extensions;
			sourceTree = "<group>";
		};
		1FD4BBD829AE9CAF00B52FBC /* Assets */ = {
			isa = PBXGroup;
			children = (
				32AF04FB2A8BE0C50080BDCD /* deletePiece.wav */,
				32AFFAD52AB0FC6E0093488C /* endRide.wav */,
				32AF04FA2A8BE0C50080BDCD /* fishSound_longLoudHappy.wav */,
				32AF04FE2A8BE0C60080BDCD /* fishSound_mediumHappy.wav */,
				32AF04FF2A8BE0C60080BDCD /* fishSound_quietHappy.wav */,
				32AF05012A8BE0C60080BDCD /* pickUp.wav */,
				32AF05052A8BE0C70080BDCD /* placePiece.wav */,
				32AFFAD32AB0FC5C0093488C /* startRide.wav */,
				32AF05022A8BE0C70080BDCD /* swiftSplash_BuildMode.wav */,
				32AF04FD2A8BE0C60080BDCD /* swiftSplash_Menu.wav */,
				32AF04F92A8BE0C50080BDCD /* swiftSplash_RideMode.m4a */,
				32AF05002A8BE0C60080BDCD /* waterFlowing.wav */,
			);
			path = Assets;
			sourceTree = "<group>";
		};
		6F638E4B1FF9394F7F4DE68D /* Configuration */ = {
			isa = PBXGroup;
			children = (
				069DF3ADB744789956636AF1 /* SampleCode.xcconfig */,
			);
			name = Configuration;
			sourceTree = "<group>";
		};
/* End PBXGroup section */

/* Begin PBXNativeTarget section */
		1F6BF6122919C4D8006F6A58 /* SwiftSplash */ = {
			isa = PBXNativeTarget;
			buildConfigurationList = 1F6BF6282919C4D9006F6A58 /* Build configuration list for PBXNativeTarget "SwiftSplash" */;
			buildPhases = (
				1F6BF60F2919C4D8006F6A58 /* Sources */,
				1F6BF6102919C4D8006F6A58 /* Frameworks */,
				1F6BF6112919C4D8006F6A58 /* Resources */,
			);
			buildRules = (
			);
			dependencies = (
			);
			name = SwiftSplash;
			packageProductDependencies = (
				1F13D56D2984620500EC78A8 /* SwiftSplashTrackPieces */,
			);
			productName = SwiftSplash;
			productReference = 1F6BF6132919C4D8006F6A58 /* SwiftSplash.app */;
			productType = "com.apple.product-type.application";
		};
/* End PBXNativeTarget section */

/* Begin PBXProject section */
		1F6BF60B2919C4D8006F6A58 /* Project object */ = {
			isa = PBXProject;
			attributes = {
				BuildIndependentTargetsInParallel = 1;
				LastSwiftUpdateCheck = 1430;
				LastUpgradeCheck = 1510;
				ORGANIZATIONNAME = Apple;
				TargetAttributes = {
					1F6BF6122919C4D8006F6A58 = {
						CreatedOnToolsVersion = 14.3;
					};
				};
			};
			buildConfigurationList = 1F6BF60E2919C4D8006F6A58 /* Build configuration list for PBXProject "SwiftSplash" */;
			compatibilityVersion = "Xcode 14.0";
			developmentRegion = en;
			hasScannedForEncodings = 0;
			knownRegions = (
				en,
				Base,
			);
			mainGroup = 1F6BF60A2919C4D8006F6A58;
			productRefGroup = 1F6BF6142919C4D8006F6A58 /* Products */;
			projectDirPath = "";
			projectRoot = "";
			targets = (
				1F6BF6122919C4D8006F6A58 /* SwiftSplash */,
			);
		};
/* End PBXProject section */

/* Begin PBXResourcesBuildPhase section */
		1F6BF6112919C4D8006F6A58 /* Resources */ = {
			isa = PBXResourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				32AF05062A8BE0C70080BDCD /* swiftSplash_RideMode.m4a in Resources */,
				1F6BF6242919C4D9006F6A58 /* Preview Assets.xcassets in Resources */,
				32AF050F2A8BE0C70080BDCD /* swiftSplash_BuildMode.wav in Resources */,
				32AFFAD62AB0FC6E0093488C /* endRide.wav in Resources */,
				32AF050E2A8BE0C70080BDCD /* pickUp.wav in Resources */,
				32AF05122A8BE0C70080BDCD /* placePiece.wav in Resources */,
				32AF05082A8BE0C70080BDCD /* deletePiece.wav in Resources */,
				32AF050C2A8BE0C70080BDCD /* fishSound_quietHappy.wav in Resources */,
				32AF050A2A8BE0C70080BDCD /* swiftSplash_Menu.wav in Resources */,
				32AF050B2A8BE0C70080BDCD /* fishSound_mediumHappy.wav in Resources */,
				32AF05072A8BE0C70080BDCD /* fishSound_longLoudHappy.wav in Resources */,
				32AFFAD42AB0FC5C0093488C /* startRide.wav in Resources */,
				1F6BF6212919C4D9006F6A58 /* Assets.xcassets in Resources */,
				32AF050D2A8BE0C70080BDCD /* waterFlowing.wav in Resources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXResourcesBuildPhase section */

/* Begin PBXSourcesBuildPhase section */
		1F6BF60F2919C4D8006F6A58 /* Sources */ = {
			isa = PBXSourcesBuildPhase;
			buildActionMask = 2147483647;
			files = (
				1F52B60F2A97C49F00C93EB9 /* AppConfig.swift in Sources */,
				1FC75A762AA1183A005B6A87 /* AppState+PieceSelection.swift in Sources */,
				32AF04F82A8BDC270080BDCD /* SoundEffects.swift in Sources */,
				1F8922C32926C9A2005E1B39 /* Piece.swift in Sources */,
				1FDA9A092993F98000CD1951 /* EditTrackPieceView.swift in Sources */,
				1F46FAC0292408F600B38A70 /* PieceShelfView.swift in Sources */,
				1FEFF2DB2AA10C66002B43C7 /* AppState+Transparency.swift in Sources */,
				1F5ED3072A81B04C00843A5A /* TrackBuildingView+Snapping.swift in Sources */,
				1FFF8F95293FEDE1000B15BB /* PlaceStartPieceView.swift in Sources */,
				1F6BF61B2919C4D8006F6A58 /* SwiftSplashApp.swift in Sources */,
				1FEB134C2ABD0A68007C36F7 /* Entity+SwiftSplash.swift in Sources */,
				1F7D201D2926899100FC115F /* ImageButton.swift in Sources */,
				1FC75A702AA115AE005B6A87 /* Date+Logging.swift in Sources */,
				1F6BF61F2919C4D8006F6A58 /* ContentView.swift in Sources */,
				1FC75A742AA1172F005B6A87 /* TrackBuildingView+Rotation.swift in Sources */,
				1F59CE052989B248008566FF /* AppPhase.swift in Sources */,
				1F2FE882291DA7CD008D6795 /* AppState.swift in Sources */,
				1F46FABE2922E9C100B38A70 /* TrackBuildingView.swift in Sources */,
				1F54B77A29773E4100D5E2B2 /* AppState+Phases.swift in Sources */,
				1F59CE01298854C8008566FF /* AppState+PieceManagement.swift in Sources */,
				8DA28C5A29D5010B00132CFC /* RideControlView.swift in Sources */,
				1F52B6112A9917B600C93EB9 /* AppState+RideRunning.swift in Sources */,
				1F5ED3092A82B75100843A5A /* AppState+TrackUpdates.swift in Sources */,
				1FC75A722AA1167A005B6A87 /* TrackBuildingView+Drag.swift in Sources */,
				1F30FEED2AA12644006352A2 /* AppState+PieceLoading.swift in Sources */,
				1F30FF692AA140E6006352A2 /* PieceShelfTrackButtonsView.swift in Sources */,
				1FB4DEF6294014B900F8CABB /* SplashScreenView.swift in Sources */,
			);
			runOnlyForDeploymentPostprocessing = 0;
		};
/* End PBXSourcesBuildPhase section */

/* Begin XCBuildConfiguration section */
		1F6BF6262919C4D9006F6A58 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 069DF3ADB744789956636AF1 /* SampleCode.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = dwarf;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_TESTABILITY = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_DYNAMIC_NO_PIC = NO;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_OPTIMIZATION_LEVEL = 0;
				GCC_PREPROCESSOR_DEFINITIONS = (
					"DEBUG=1",
					"$(inherited)",
				);
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MTL_ENABLE_DEBUG_INFO = INCLUDE_SOURCE;
				MTL_FAST_MATH = YES;
				ONLY_ACTIVE_ARCH = YES;
				SDKROOT = xros;
				SWIFT_ACTIVE_COMPILATION_CONDITIONS = DEBUG;
				SWIFT_OPTIMIZATION_LEVEL = "-Onone";
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Debug;
		};
		1F6BF6272919C4D9006F6A58 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 069DF3ADB744789956636AF1 /* SampleCode.xcconfig */;
			buildSettings = {
				ALWAYS_SEARCH_USER_PATHS = NO;
				ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS = YES;
				CLANG_ANALYZER_NONNULL = YES;
				CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION = YES_AGGRESSIVE;
				CLANG_CXX_LANGUAGE_STANDARD = "gnu++20";
				CLANG_ENABLE_MODULES = YES;
				CLANG_ENABLE_OBJC_ARC = YES;
				CLANG_ENABLE_OBJC_WEAK = YES;
				CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING = YES;
				CLANG_WARN_BOOL_CONVERSION = YES;
				CLANG_WARN_COMMA = YES;
				CLANG_WARN_CONSTANT_CONVERSION = YES;
				CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS = YES;
				CLANG_WARN_DIRECT_OBJC_ISA_USAGE = YES_ERROR;
				CLANG_WARN_DOCUMENTATION_COMMENTS = YES;
				CLANG_WARN_EMPTY_BODY = YES;
				CLANG_WARN_ENUM_CONVERSION = YES;
				CLANG_WARN_INFINITE_RECURSION = YES;
				CLANG_WARN_INT_CONVERSION = YES;
				CLANG_WARN_NON_LITERAL_NULL_CONVERSION = YES;
				CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF = YES;
				CLANG_WARN_OBJC_LITERAL_CONVERSION = YES;
				CLANG_WARN_OBJC_ROOT_CLASS = YES_ERROR;
				CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER = YES;
				CLANG_WARN_RANGE_LOOP_ANALYSIS = YES;
				CLANG_WARN_STRICT_PROTOTYPES = YES;
				CLANG_WARN_SUSPICIOUS_MOVE = YES;
				CLANG_WARN_UNGUARDED_AVAILABILITY = YES_AGGRESSIVE;
				CLANG_WARN_UNREACHABLE_CODE = YES;
				CLANG_WARN__DUPLICATE_METHOD_MATCH = YES;
				COPY_PHASE_STRIP = NO;
				DEBUG_INFORMATION_FORMAT = "dwarf-with-dsym";
				ENABLE_NS_ASSERTIONS = NO;
				ENABLE_STRICT_OBJC_MSGSEND = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = YES;
				GCC_C_LANGUAGE_STANDARD = gnu11;
				GCC_NO_COMMON_BLOCKS = YES;
				GCC_WARN_64_TO_32_BIT_CONVERSION = YES;
				GCC_WARN_ABOUT_RETURN_TYPE = YES_ERROR;
				GCC_WARN_UNDECLARED_SELECTOR = YES;
				GCC_WARN_UNINITIALIZED_AUTOS = YES_AGGRESSIVE;
				GCC_WARN_UNUSED_FUNCTION = YES;
				GCC_WARN_UNUSED_VARIABLE = YES;
				MTL_ENABLE_DEBUG_INFO = NO;
				MTL_FAST_MATH = YES;
				SDKROOT = xros;
				SWIFT_COMPILATION_MODE = wholemodule;
				SWIFT_OPTIMIZATION_LEVEL = "-O";
				VALIDATE_PRODUCT = YES;
				XROS_DEPLOYMENT_TARGET = 1.0;
			};
			name = Release;
		};
		1F6BF6292919C4D9006F6A58 /* Debug */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 069DF3ADB744789956636AF1 /* SampleCode.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_TIDY_MISC_REDUNDANT_EXPRESSION = YES;
				CODE_SIGN_IDENTITY = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEAD_CODE_STRIPPING = YES;
				DEVELOPMENT_ASSET_PATHS = "\"SwiftSplash/Preview Content\"";
				DEVELOPMENT_TEAM = "";
				ENABLE_PREVIEWS = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_WARN_UNUSED_LABEL = YES;
				GCC_WARN_UNUSED_PARAMETER = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.example.apple-samplecode.SwiftSplash${SAMPLE_CODE_DISAMBIGUATOR}";
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SDKROOT = xros;
				SUPPORTED_PLATFORMS = "xros xrsimulator";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_STRICT_CONCURRENCY = minimal;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,7";
			};
			name = Debug;
		};
		1F6BF62A2919C4D9006F6A58 /* Release */ = {
			isa = XCBuildConfiguration;
			baseConfigurationReference = 069DF3ADB744789956636AF1 /* SampleCode.xcconfig */;
			buildSettings = {
				ASSETCATALOG_COMPILER_APPICON_NAME = AppIcon;
				ASSETCATALOG_COMPILER_GLOBAL_ACCENT_COLOR_NAME = AccentColor;
				CLANG_TIDY_MISC_REDUNDANT_EXPRESSION = YES;
				CODE_SIGN_IDENTITY = "Apple Development";
				CODE_SIGN_STYLE = Automatic;
				CURRENT_PROJECT_VERSION = 1;
				DEAD_CODE_STRIPPING = YES;
				DEVELOPMENT_ASSET_PATHS = "\"SwiftSplash/Preview Content\"";
				DEVELOPMENT_TEAM = "";
				ENABLE_PREVIEWS = YES;
				ENABLE_USER_SCRIPT_SANDBOXING = NO;
				GCC_WARN_UNUSED_LABEL = YES;
				GCC_WARN_UNUSED_PARAMETER = YES;
				GENERATE_INFOPLIST_FILE = YES;
				INFOPLIST_FILE = "";
				INFOPLIST_KEY_UIApplicationSceneManifest_Generation = YES;
				LD_RUNPATH_SEARCH_PATHS = (
					"$(inherited)",
					"@executable_path/Frameworks",
				);
				MARKETING_VERSION = 1.0;
				PRODUCT_BUNDLE_IDENTIFIER = "com.example.apple-samplecode.SwiftSplash${SAMPLE_CODE_DISAMBIGUATOR}";
				PRODUCT_NAME = "$(TARGET_NAME)";
				PROVISIONING_PROFILE_SPECIFIER = "";
				SDKROOT = xros;
				SUPPORTED_PLATFORMS = "xros xrsimulator";
				SWIFT_EMIT_LOC_STRINGS = YES;
				SWIFT_STRICT_CONCURRENCY = minimal;
				SWIFT_VERSION = 5.0;
				TARGETED_DEVICE_FAMILY = "1,2,7";
			};
			name = Release;
		};
/* End XCBuildConfiguration section */

/* Begin XCConfigurationList section */
		1F6BF60E2919C4D8006F6A58 /* Build configuration list for PBXProject "SwiftSplash" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1F6BF6262919C4D9006F6A58 /* Debug */,
				1F6BF6272919C4D9006F6A58 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
		1F6BF6282919C4D9006F6A58 /* Build configuration list for PBXNativeTarget "SwiftSplash" */ = {
			isa = XCConfigurationList;
			buildConfigurations = (
				1F6BF6292919C4D9006F6A58 /* Debug */,
				1F6BF62A2919C4D9006F6A58 /* Release */,
			);
			defaultConfigurationIsVisible = 0;
			defaultConfigurationName = Release;
		};
/* End XCConfigurationList section */

/* Begin XCSwiftPackageProductDependency section */
		1F13D56D2984620500EC78A8 /* SwiftSplashTrackPieces */ = {
			isa = XCSwiftPackageProductDependency;
			productName = SwiftSplashTrackPieces;
		};
/* End XCSwiftPackageProductDependency section */
	};
	rootObject = 1F6BF60B2919C4D8006F6A58 /* Project object */;
}

----!@#$----
SwiftSplash.xcodeproj/.xcodesamplecode.plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<array/>
</plist>

----!@#$----
SwiftSplash.xcodeproj/project.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>BuildSystemType</key>
	<string>Latest</string>
</dict>
</plist>

----!@#$----
SwiftSplash.xcodeproj/xcshareddata/xcschemes/SwiftSplash.xcscheme
<?xml version="1.0" encoding="UTF-8"?>
<Scheme
   LastUpgradeVersion = "1510"
   version = "1.3">
   <BuildAction
      parallelizeBuildables = "YES"
      buildImplicitDependencies = "YES">
      <BuildActionEntries>
         <BuildActionEntry
            buildForTesting = "YES"
            buildForRunning = "YES"
            buildForProfiling = "YES"
            buildForArchiving = "YES"
            buildForAnalyzing = "YES">
            <BuildableReference
               BuildableIdentifier = "primary"
               BlueprintIdentifier = "1F6BF6122919C4D8006F6A58"
               BuildableName = "SwiftSplash.app"
               BlueprintName = "SwiftSplash"
               ReferencedContainer = "container:SwiftSplash.xcodeproj">
            </BuildableReference>
         </BuildActionEntry>
      </BuildActionEntries>
   </BuildAction>
   <TestAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      shouldUseLaunchSchemeArgsEnv = "YES">
      <Testables>
      </Testables>
   </TestAction>
   <LaunchAction
      buildConfiguration = "Debug"
      selectedDebuggerIdentifier = "Xcode.DebuggerFoundation.Debugger.LLDB"
      selectedLauncherIdentifier = "Xcode.DebuggerFoundation.Launcher.LLDB"
      launchStyle = "0"
      useCustomWorkingDirectory = "NO"
      ignoresPersistentStateOnLaunch = "NO"
      debugDocumentVersioning = "YES"
      debugServiceExtension = "internal"
      allowLocationSimulation = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "1F6BF6122919C4D8006F6A58"
            BuildableName = "SwiftSplash.app"
            BlueprintName = "SwiftSplash"
            ReferencedContainer = "container:SwiftSplash.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </LaunchAction>
   <ProfileAction
      buildConfiguration = "Release"
      shouldUseLaunchSchemeArgsEnv = "YES"
      savedToolIdentifier = ""
      useCustomWorkingDirectory = "NO"
      debugDocumentVersioning = "YES">
      <BuildableProductRunnable
         runnableDebuggingMode = "0">
         <BuildableReference
            BuildableIdentifier = "primary"
            BlueprintIdentifier = "1F6BF6122919C4D8006F6A58"
            BuildableName = "SwiftSplash.app"
            BlueprintName = "SwiftSplash"
            ReferencedContainer = "container:SwiftSplash.xcodeproj">
         </BuildableReference>
      </BuildableProductRunnable>
   </ProfileAction>
   <AnalyzeAction
      buildConfiguration = "Debug">
   </AnalyzeAction>
   <ArchiveAction
      buildConfiguration = "Release"
      revealArchiveInOrganizer = "YES">
   </ArchiveAction>
</Scheme>

----!@#$----
Packages/SwiftSplashTrackPieces/README.md
# SwiftSplashTrackPieces

This Swift package is a Reality Composer Pro project. It contains all of the individual slide pieces that Swift Splash uses. The project stores each slide piece in its own scene. It also contains additional scenes containing materials shared by more than one scene.
----!@#$----
Packages/SwiftSplashTrackPieces/Package.swift
// swift-tools-version: 5.7
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A package that contains model assets.
*/
import PackageDescription

let package = Package(
    name: "SwiftSplashTrackPieces",
    platforms: [
        .custom("xros", versionString: "1.0")
    ],
    products: [
        // Products define the executables and libraries a package produces, and make them visible to other packages.
        .library(
            name: "SwiftSplashTrackPieces",
            targets: ["SwiftSplashTrackPieces"])
    ],
    dependencies: [
        // Dependencies declare other packages that this package depends on.
        // .package(url: /* package url */, from: "1.0.0"),
    ],
    targets: [
        // Targets are the basic building blocks of a package. A target can define a module or a test suite.
        // Targets can depend on other targets in this package, and on products in packages this package depends on.
        .target(
            name: "SwiftSplashTrackPieces",
            dependencies: [])
        // .testTarget(
        //     name: "SwiftSplashTrackPiecesTests",
        //     dependencies: ["SwiftSplashTrackPieces"]),
    ]
)

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/SwiftSplashTrackPieces.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Constants and enums the app uses to interact with the Reality Compoer Pro project.
*/

import Foundation

public let bundle = Bundle.module
public let startPieceName = "start"
public let endPieceName = "end"
public let slideTopName = "top"
public let poweredMaterialParameterName = "powered"
public let inConnectionName = "connect_in"
public let inConnectionVectorName = "in_connection_vector"
public let outConnectionName = "connect_out"
public let outConnectionVectorName = "out_connection_vector"
public let placePieceMarkerName = "solidSpheres"
public let shelfPositionLocationName = "shelf_position"
public let uiPositionMarker = "ui_anchor"
public let instructionsMarkerName = "instructions_anchor"
public let selectedGlowName = "glow"
public let startGlowName = "start_glow"
public let materialParameterName = "material"
public let speedMultiplierParameterName = "speed_multiplier"
public let rideRunningParameterName = "ride_running"
public let fillLevelParameterName = "fill_level"
public let startPieceSceneName = "StartPiece.usda"
public let endPieceSceneName = "EndPiece.usda"
public let placePieceMarkerSceneName = "solidSpheres.usda"
public let sortOrderGlassGlobeName = "start_glass"
public let sortOrderWaterName = "waterDrain_ride_animation"
public let fishGlassIdleAnimModelName = "adventureFish_start_glass_idle_animation"
public let fishGlassRideAnimModelName = "adventureFish_start_glass_ride_animation"
public let fishIdleAnimModelName = "adventureFish_start_noGlass_idle_animation"
public let fishRideAnimModelName = "adventureFish_start_noGlass_ride_animation"
public let sortOrderFishGlassSuffix = "noGlass_ride_animation"
public let sortOrderFishSuffix = "glass_ride_animation"
public let sortOrderWaterSuffix = "_water"
public let sortOrderTrackTopsuffix = "_top"
public let sortOrderTrackBottomSuffix = "_bottom"
public let sortOrderTrackBottomGlowSuffix = "_bottom_glow"
public let sortOrderTrackGlowSuffix = "_top_glow"
public let sortOrderEndWaterName = "end_water"
public let sortOrderEndSlideName = "slide_end_water"
public let sortOrderEndSlideTopName = "slideEnd_top"
public let waterLevelParameterName = "water_level"
public let endParticlesName = "EndParticles"
public let waterFallParticlesName = "waterFallSplash"
public let fireworksParticlesName = "fireWorks"
public let fishSplashParticleName = "fishSplash"

public enum MaterialType: Int {
    case metal = 0
    case plastic
    case wood

    public var name: String {
        switch self {
            case .metal:
                return "metal"
            case .plastic:
                return "plastic"
            case .wood:
                return "wood"

        }
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Extensions/Float+Utilities.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on Float containing an app-specific nearly equal to operator.
*/

import Foundation

infix operator ==~

public extension Float {
    
    /// Float comparison with an epislon of 0.00001. This isn't a general purpose nearly-equal-to operator;
    /// it uses an epsilon value tuned to work well for snapping track pieces together.
    static func ==~ (lhs: Float, rhs: Float) -> Bool {
        return abs(lhs - rhs) <= 1e-5
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Extensions/Entity+Utilities.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
An extension on Entity containing convenience and utility functions.
*/

import Foundation
import OSLog
import RealityKit

/// Convenience methods for `Entity`.
public extension Entity {
    
    /// Returns an array containing all descendants with a name that includes a specified substring.
    func descendants(containingSubstring substring: String) -> [Entity] {
        var childTransforms = children.filter { child in
            return child.name.contains(substring)
        }
        var myTransforms = [Entity]()
        for child in children {
            childTransforms.append(contentsOf: child.descendants(containingSubstring: substring))
        }
        myTransforms.append(contentsOf: childTransforms)
        return myTransforms
    }
    
    /// Recursive search of children returning any descendants with a specific component and calling a closure with them.
    func forEachDescendant(containingSubstring substring: String, _ closure: (Entity) -> Void) {
        for child in children {
            if child.name.contains(substring) {
                closure(child)
            }
            child.forEachDescendant(containingSubstring: substring, closure)
        }
    }
    
    /// Recursive search of children with a name that has a specified suffix.
    func forEachDescendant(withSuffix suffix: String, _ closure: (Entity) -> Void) {
        for child in children {
            if child.name.hasSuffix(suffix) {
                closure(child)
            }
            child.forEachDescendant(withSuffix: suffix, closure)
        }
    }
    
    /// Returns the position of the entity specified in the app's coordinate system. On
    /// iOS and macOS, which don't have a device native coordinate system, scene
    /// space is often referred to as "world space".
    var scenePosition: SIMD3<Float> {
        get { position(relativeTo: nil) }
        set { setPosition(newValue, relativeTo: nil) }
    }
    
    /// Returns the orientation of the entity specified in the app's coordinate system. On
    /// iOS and macOS, which don't have a device native coordinate system, scene
    /// space is often referred to as "world space".
    var sceneOrientation: simd_quatf {
        get { orientation(relativeTo: nil) }
        set { setOrientation(newValue, relativeTo: nil) }
    }
}

/// Entity extension holding convenience accessors and mutators for the components
/// this system uses. Components are stored in the `components` dictionary using the
/// component class (`.self`) as the key. This adds calculated properties to allow setting
/// and getting these components.
public extension Entity {
    /// Property for getting or setting an entity's `ConnectableComponent`.
    var connectableComponent: ConnectableComponent? {
        get { components[ConnectableComponent.self] }
        set { components[ConnectableComponent.self] = newValue }
    }
    
    /// Property for getting or setting an entity's `CollisionComponent`.
    var collisionComponent: CollisionComponent? {
        get { components[CollisionComponent.self] }
        set { components[CollisionComponent.self] = newValue }
    }
    
    /// Property for getting or setting an entity's `ConnectableStateComponent`.
    var connectableStateComponent: ConnectableStateComponent? {
        get { components[ConnectableStateComponent.self] }
        set { components[ConnectableStateComponent.self] = newValue }
    }

    /// Property for getting or setting an entity's `ModelComponent`.
    var modelComponent: ModelComponent? {
        get { components[ModelComponent.self] }
        set { components[ModelComponent.self] = newValue }
    }
    
    /// Property for getting or setting an entity's `RideAnimationComponent`.
    var rideAnimationComponent: RideAnimationComponent? {
        get { components[RideAnimationComponent.self] }
        set { components[RideAnimationComponent.self] = newValue }
    }
    
    /// Property for getting or setting an entity's `IdleAnimationComponent`.
    var idleAnimationComponent: IdleAnimationComponent? {
        get { components[IdleAnimationComponent.self] }
        set { components[IdleAnimationComponent.self] = newValue }
    }
    
    /// Property for getting or setting an entity's `GlowComponent`.
    var glowComponent: GlowComponent? {
        get { components[GlowComponent.self] }
        set { components[GlowComponent.self] = newValue }
    }
    
    var particleEmitterComponent: ParticleEmitterComponent? {
        get { components[ParticleEmitterComponent.self] }
        set { components[ParticleEmitterComponent.self] = newValue }
    }
}

// MARK: - Connected Power System -
public extension Entity {
    
    /// Marks a track piece as powered, indicating it's connected back to the start piece.
    func turnOnPower() {
        setPower(isPowered: true)
    }
    
    /// Marks a track piece as unpowered, indicating it isn't connected back to the start piece.
    func turnOffPower() {
        setPower(isPowered: false)
    }
    
    /// Updates dynamic Shader Graph materials based on the current state of the track piece and
    /// also hides and shows prims that are state-dependent, such as the slide top pieces, which are
    /// only visible when the metal material is selected.
    func updateTrackPieceAppearance() {
        forEachDescendant(withComponent: ModelComponent.self) { modelEntity, component in
            var modelComponent = component
            modelComponent.materials = modelComponent.materials.map {
                guard var material = $0 as? ShaderGraphMaterial else { return $0 }
                if material.parameterNames.contains(materialParameterName) {
                    do {
                        let pieceMaterial = Int32( connectableStateComponent?.material.rawValue ?? MaterialType.metal.rawValue)
                        let materialIndex = MaterialParameters.Value.int(pieceMaterial)
                        try material.setParameter(name: materialParameterName,
                                                  value: materialIndex)
                    } catch {
                        os_log(.error, "Error setting track material parameter: %s", error.localizedDescription)
                    }
                }
                return material
            }
            modelEntity.modelComponent = modelComponent
        }

        // Hide or show the top part of the slide depending on the material.
        for entity in self.descendants(containingSubstring: SwiftSplashTrackPieces.slideTopName) {
            if let state = connectableStateComponent {
                if state.material == .metal {
                    if entity.name.hasSuffix("_glow") {
                        entity.isEnabled = state.isSelected
                    } else {
                        entity.isEnabled = true
                    }
                } else {
                    entity.isEnabled = false
                }
                
            }
        }
        
        self.forEachDescendant(withComponent: GlowComponent.self) { entity, component in
            guard let state = connectableStateComponent else { return }
            entity.isEnabled = state.isSelected
        }
    }
    
    func setPower(isPowered: Bool, isChild: Bool = false) {
        for child in children {
            child.setPower(isPowered: isPowered, isChild: true)
        }
        
        if !isChild {
            if var stateComponent = self.connectableStateComponent {
                // Because it's set to the same value it already is, no need to do anything.
                if isPowered == stateComponent.isPowered { return }
                
                // Value changes, so store it in the powered component.
                stateComponent.isPowered = isPowered
                self.connectableStateComponent = stateComponent
            }
        }
        
        if var modelComponent = self.modelComponent {
            modelComponent.materials = modelComponent.materials.map {
                guard var material = $0 as? ShaderGraphMaterial else { return $0 }
                if material.parameterNames.contains(poweredMaterialParameterName) {
                    do {
                        try material.setParameter(name: poweredMaterialParameterName, value: .float(isPowered ? 1.0 : 0.0))
                    } catch {
                        os_log("Error setting Powered parameter: \(error.localizedDescription)")
                    }
                }
                return material
            }
            self.modelComponent = modelComponent
        }
    }
    
    /// An entity that marks where this piece connects to the previous piece.
    var inConnection: Entity? {
        findEntity(named: SwiftSplashTrackPieces.inConnectionName)
    }
    
    /// An entity that marks where this piece connects to the next piece.
    var outConnection: Entity? {
        findEntity(named: SwiftSplashTrackPieces.outConnectionName)
    }
    
    /// A vector that indicates the direction of the piece's in connection.
    var inConnectionVector: Entity? {
        findEntity(named: SwiftSplashTrackPieces.inConnectionVectorName)
    }
    
    /// A vector that indicates the direction of the piece's out connection.
    var outConnectionVector: Entity? {
        findEntity(named: SwiftSplashTrackPieces.outConnectionVectorName)
    }
    
    /// Finds the entity containing the connectable component in this entity or one of its ancestors.
    var connectableAncestor: Entity? {
        if connectableComponent != nil {
            return self
        }
        var nextParent: Entity? = parent
        
        while nextParent != nil {
            if nextParent?.connectableComponent != nil {
                return nextParent
            }
            nextParent = nextParent?.parent
        }
        return nil
    }
    
    /// Each track piece other than the start, goal, and placeholder pieces have a child transform
    /// that identifies where to place its edit UI. This returns it.
    var uiAnchor: Entity? {
        self.findEntity(named: uiPositionMarker)
    }
    
    var instructionsMarker: Entity? {
        self.findEntity(named: instructionsMarkerName)
    }
}

public extension Entity {
    
    /// Recursive search of children looking for any descendants with a specific component and calling a closure with them.
    func forEachDescendant<T: Component>(withComponent componentClass: T.Type, _ closure: (Entity, T) -> Void) {
        for child in children {
            if let component = child.components[componentClass] {
                closure(child, component)
            }
            child.forEachDescendant(withComponent: componentClass, closure)
        }
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Extensions/SIMD+Utilities.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Contains extensions on SIMD objects.
*/

import Foundation
import RealityKit
import simd

public let pi_2 = Float.pi / 2.0

/// Adds an approximately equal operator, a convenience `up` vector, and some utility methods.
public extension SIMD3 where Scalar == Float {
    
    /// Returns a vector that represents an up vector. Used for rotating around the `Y` axis (yaw)
    static let up = SIMD3<Float>(x: 0, y: 1, z: 0)
    
    /// The magnitude of this vector.
    var magnitude: Float {
        return simd_length(self)
    }
    
    /// Returns a vector with all values set to `0.0`.
    static let zero = SIMD3<Float>.zero
}

public extension simd_float4x4 {
    
    /// Returns the forward vector for the orientation represented by this matrix.
    var forward: SIMD3<Float> {
        simd_normalize(SIMD3<Float>(columns.2.x, columns.2.y, columns.2.z))
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Components/ConnectableStateComponent.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A component that holds state values for connectable slide pieces.
*/

import Foundation
import RealityKit
import Combine
import AVFoundation
import struct SwiftUI.Angle

/// A component to hold internal state values. The project separates these values into a
/// separate component from `ConnectableComponent` so that Reality Composer Pro doesn't display these values.
/// Swift Splash automatically adds one of these to any entity with a `ConnectableComponent`.
public struct ConnectableStateComponent: Component, CustomStringConvertible {
    public var dragStart: SIMD3<Float>? = nil
    public var dragOffset = SIMD3<Float>.zero
    public var lastMoved: TimeInterval = 0
    
    public var rotationAngle = simd_quatf(angle: 0.0, axis: SIMD3<Float>.up)
    
    /// The entity this component is currently attached to.
    public var entity: Entity?
    
    /// Whether the piece has power or not.
    public var isPowered = false
    
    /// Whether the piece is selected.
    public var isSelected = false
    
    /// If another connectible piece is connected to this piece's out connection, this holds that connected piece.
    public var nextPiece: Entity?
    
    /// If another connectible piece is connected to this piece's in connection, this holds that connected piece.
    public var previousPiece: Entity?
    
    /// Stores the point where this piece can connect to a previous piece. This is a `Transform`
    /// that's stored as a child entity.
    public var inConnection: Entity? = nil
    
    /// Stores the point where this piece can connect to the next piece. This is a `Transform`
    /// that's stored as a child entity.
    public var outConnection: Entity? = nil
    
    /// Stores the entity's rotation on the Y axis in radians at the time the current gesture started.
    public var startRotation: Double = 0
    
    /// The type of material to use for this piece (metal, wood, or plastic).
    public var material: MaterialType = .metal
    
    public var description: String {
        return "dragStart: \(String(describing: dragStart)), dragOffset: \(dragOffset), " +
                "lastMoved: \(lastMoved), rotationAngle: \(rotationAngle), next piece:" +
                "\(String(describing: nextPiece?.name)), previous piece: " +
                "\(String(describing: previousPiece?.name)), material: \(String(describing: material))"
    }
    
    public init() {}
    
    /// Calculates the world position for a piece being dragged based on `dragStart` and `dragOffset`.
    /// Returns `nil` if the pieces is not being dragged.
    public var worldPosition: SIMD3<Float>? {
        if let dragStart = dragStart {
            return dragStart + dragOffset
        }
        return nil
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Components/BillboardComponent.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A component that marks a piece that will always face the camera.
*/

import Foundation
import RealityKit

/// The component that marks an entity as a billboard object which will always face the camera.
public struct BillboardComponent: Component, Codable {
    public init() {
    }
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Components/Connectable.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A component that marks a ride piece that can connect to other pieces.
*/

import Foundation
import RealityKit

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as a
/// piece that can be connected to other pieces.
public struct ConnectableComponent: Component, Codable {
    public init() {}
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Components/MarkerComponents.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
Components the app uses to mark entities in the Reality Composer Pro project.
*/

import Foundation
import RealityKit

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as
/// marking the location where the "Place Start View" attachment goes.
public struct PlaceStartPieceUIMarkerComponent: Component, Codable {
}

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as
/// marking the location where the "Place Start View" attachment goes.
public struct EditUILocationMarkerComponent: Component, Codable {
}

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as having
/// an animation that plays while the ride is running.
public struct RideAnimationComponent: Component, Codable {
    /// A Boolean that identifies whether this entity will be visible when the ride isn't running. If set
    /// to `true`, the entity will always be visible, but will only animated during the ride run when it's
    /// scene is the active one. If set to `false`, the entity is hidden when not animating.
    public var isPersistent = true
    
    /// How far into the ride animation to trigger the next animation.
    public var duration = 1.0
    
    /// If set to `true`, the animations run during the entire ride, not just when that one track piece is active.
    /// `isPersistent` must also be `true` for this to work because otherwise, the entity will be hidden
    /// when its track piece isn't active.
    public var alwaysAnimates = false
    
    public var timecodeWhenNotPlaying: Double = 0
}

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as having
/// an idle animation that plays while the ride isn't running.
public struct IdleAnimationComponent: Component, Codable {
    /// Normally, idle animations play whenever the ride isn't running. If an animation needs
    /// to run after the ride ends rather than before (for example, the idle animation in the end piece)
    /// set this to `true`.
    public var playAtEndInsteadOfBeginning = false
}

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` as being
/// ride water that only displays when the ride is running.
public struct RideWaterComponent: Component, Codable {
    /// Identifies at what point in vertical UV space fills the water completely..
    public var fillLevel: Float = 1.0
    
    /// Identifies how long it should take for this water to fill up.
    public var duration: Float = 1.0
}

/// The component, usually added in Reality Composer Pro, that identifies an `Entity` used
/// for the selection glow. These are hidden when the object isn't selected, and shown when they are.
public struct GlowComponent: Component, Codable {
    public var isTopPiece = false
}

----!@#$----
Packages/SwiftSplashTrackPieces/Sources/SwiftSplashTrackPieces/Systems/BillboardSystem.swift
/*
See the LICENSE.txt file for this sample’s licensing information.

Abstract:
A system that keeps entities facing the camera at all times.
*/

import ARKit
import Foundation
import OSLog
import RealityKit
import simd
import SwiftUI

/// An ECS system that points all entities containing a billboard component at the camera.
public struct BillboardSystem: System {
    
    static let query = EntityQuery(where: .has(SwiftSplashTrackPieces.BillboardComponent.self))
    
    private let arkitSession = ARKitSession()
    private let worldTrackingProvider = WorldTrackingProvider()
    
    public init(scene: RealityKit.Scene) {
        setUpSession()
    }
    
    func setUpSession() {
        
        Task {
            do {
                try await arkitSession.run([worldTrackingProvider])
            } catch {
                os_log(.info, "Error: \(error)")
            }
        }
    }
    
    public func update(context: SceneUpdateContext) {
        
        let entities = context.scene.performQuery(Self.query).map({ $0 })
        
        guard !entities.isEmpty,
              let pose = worldTrackingProvider.queryDeviceAnchor(atTimestamp: CACurrentMediaTime()) else { return }
        
        let cameraTransform = Transform(matrix: pose.originFromAnchorTransform)
        
        for entity in entities {
            entity.look(at: cameraTransform.translation,
                        from: entity.scenePosition,
                        relativeTo: nil,
                        forward: .positiveZ)
        }
    }
}

--END--